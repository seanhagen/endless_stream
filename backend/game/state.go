package game

import (
	"github.com/seanhagen/endless_stream/backend/endless"
)

// actions are generated by actors
// for human players they are the result of an input for the current player
// for ai players, actions are the result of the ai choosing what to do next
//
type action interface {
	Exec(*Game) bool
}

type actor interface {
	// getAction is called when it's this actors turn in iniative order
	getAction(*endless.Input) (action, error)
	// iniative determines iniative order, lower goes earlier in a round
	initiative() int
}

// outputState ...
func (g *Game) outputState() *endless.Output {
	g.Lock()
	defer g.Unlock()
	// log.Printf("outputting state")

	var d endless.Display
	switch g.screenState.MustState().(GameState) {
	case StateCharSelect:
		d = endless.Display_ScreenCharSelect
	case StateNewWave:
		d = endless.Display_ScreenNewWave
	case StateWaveAnimWait:
		fallthrough
	case StateWaveInput:
		fallthrough
	case StateWaveProcess:
		fallthrough
	case StateWave:
		d = endless.Display_ScreenWave
	case StateDefeat:
		d = endless.Display_ScreenDead
	case StateGameOver:
		d = endless.Display_ScreenGameOver
	case StateVictory:
		d = endless.Display_ScreenVictory
	case StateStore:
		d = endless.Display_ScreenStore
	default:
		d = endless.Display_ScreenLoading
	}

	sc := map[string]endless.ClassType{}
	if len(g.selectedCharacters) > 0 {
		for k, v := range g.selectedCharacters {
			sc[v] = k
		}
	}
	// log.Printf("selected: %v", spew.Sdump(sc, g.selectedCharacters))

	return &endless.Output{
		Data: &endless.Output_State{
			State: &endless.CurrentState{
				Display:  d,
				Selected: &endless.CharacterSelected{Selected: sc},
				// Wave: g.waveNumber,
			},
		},
	}
}
