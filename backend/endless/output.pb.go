// Code generated by protoc-gen-go. DO NOT EDIT.
// source: output.proto

package endless

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	wrappers "github.com/golang/protobuf/ptypes/wrappers"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type Target int32

const (
	// Self means the skill/item only affects the actor
	Target_Self Target = 0
	// Melee means the actor must be in the same threat zone for the skill/item to affect them
	Target_Melee Target = 1
	// Ranged means the actor can hit any other actor, regardless of positition
	Target_Ranged Target = 2
	// AOE means the skill/item affects all other actors in the chosen threat zone
	Target_AOE Target = 3
)

var Target_name = map[int32]string{
	0: "Self",
	1: "Melee",
	2: "Ranged",
	3: "AOE",
}

var Target_value = map[string]int32{
	"Self":   0,
	"Melee":  1,
	"Ranged": 2,
	"AOE":    3,
}

func (x Target) String() string {
	return proto.EnumName(Target_name, int32(x))
}

func (Target) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{0}
}

type Position int32

const (
	Position_PlayerSide Position = 0
	Position_Middle     Position = 1
	Position_EnemySide  Position = 2
)

var Position_name = map[int32]string{
	0: "PlayerSide",
	1: "Middle",
	2: "EnemySide",
}

var Position_value = map[string]int32{
	"PlayerSide": 0,
	"Middle":     1,
	"EnemySide":  2,
}

func (x Position) String() string {
	return proto.EnumName(Position_name, int32(x))
}

func (Position) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{1}
}

// Skill represents a player skill that can be used during battle.
type Skill struct {
	// Id is the UUID of the skill
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name is the human-readable name of the skill
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Level is the current level of the skill, starts at 0 for all
	Level int32 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	// Target is for who/what the skill can target
	Target Target `protobuf:"varint,4,opt,name=target,proto3,enum=endless.stream.v1.Target" json:"target,omitempty"`
	// Cost is how much focus is required to activate the skill
	Cost int32 `protobuf:"varint,5,opt,name=cost,proto3" json:"cost,omitempty"`
	// Cooldown is how many turns it takes for the skill to become usable again
	Cooldown int32 `protobuf:"varint,6,opt,name=cooldown,proto3" json:"cooldown,omitempty"`
	// CooldownLeft is how many turns are left until the skill is usable again
	CooldownLeft int32 `protobuf:"varint,7,opt,name=cooldown_left,json=cooldownLeft,proto3" json:"cooldown_left,omitempty"`
	// Active is true when the skill is usable. If the skill isn't unlocked, or a status
	// prevents the usage of the skill, this will be false.
	Active bool `protobuf:"varint,8,opt,name=active,proto3" json:"active,omitempty"`
	// Upgradable is true while the skill is upgradable. Once a skill has reached max level
	// this becomes false.
	Upgradable bool `protobuf:"varint,9,opt,name=upgradable,proto3" json:"upgradable,omitempty"`
	// Description is a human readable name for the skill.
	Description          string   `protobuf:"bytes,50,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Skill) Reset()         { *m = Skill{} }
func (m *Skill) String() string { return proto.CompactTextString(m) }
func (*Skill) ProtoMessage()    {}
func (*Skill) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{0}
}

func (m *Skill) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Skill.Unmarshal(m, b)
}
func (m *Skill) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Skill.Marshal(b, m, deterministic)
}
func (m *Skill) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Skill.Merge(m, src)
}
func (m *Skill) XXX_Size() int {
	return xxx_messageInfo_Skill.Size(m)
}
func (m *Skill) XXX_DiscardUnknown() {
	xxx_messageInfo_Skill.DiscardUnknown(m)
}

var xxx_messageInfo_Skill proto.InternalMessageInfo

func (m *Skill) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Skill) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Skill) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Skill) GetTarget() Target {
	if m != nil {
		return m.Target
	}
	return Target_Self
}

func (m *Skill) GetCost() int32 {
	if m != nil {
		return m.Cost
	}
	return 0
}

func (m *Skill) GetCooldown() int32 {
	if m != nil {
		return m.Cooldown
	}
	return 0
}

func (m *Skill) GetCooldownLeft() int32 {
	if m != nil {
		return m.CooldownLeft
	}
	return 0
}

func (m *Skill) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Skill) GetUpgradable() bool {
	if m != nil {
		return m.Upgradable
	}
	return false
}

func (m *Skill) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Item represents something the player can carry and use.
type Item struct {
	// Id is the UUID that represents the item
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name is the human-readable name of the item
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Target is so the UI can show how many targets the item can affect
	Target Target `protobuf:"varint,3,opt,name=target,proto3,enum=endless.stream.v1.Target" json:"target,omitempty"`
	// Passive is if the item is passive/equipable
	Passive bool `protobuf:"varint,4,opt,name=passive,proto3" json:"passive,omitempty"`
	// Bonus is a map of attribute name -> bonus that shows how the item affects
	// the player character ( ongoing for passive items, or immediate bonus otherwise)
	Bonus map[string]int32 `protobuf:"bytes,6,rep,name=bonus,proto3" json:"bonus,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Count is how many copies of this item the player has
	Count int32 `protobuf:"varint,7,opt,name=count,proto3" json:"count,omitempty"`
	// Active is if the item is currently usable. Some items can be used at any time
	// (such as health potions), some are only usable on that players turn
	Active bool `protobuf:"varint,8,opt,name=active,proto3" json:"active,omitempty"`
	// Description is the human readable description of what the item is
	// and what it does
	Description          string   `protobuf:"bytes,50,opt,name=description,proto3" json:"description,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Item) Reset()         { *m = Item{} }
func (m *Item) String() string { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()    {}
func (*Item) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{1}
}

func (m *Item) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Item.Unmarshal(m, b)
}
func (m *Item) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Item.Marshal(b, m, deterministic)
}
func (m *Item) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Item.Merge(m, src)
}
func (m *Item) XXX_Size() int {
	return xxx_messageInfo_Item.Size(m)
}
func (m *Item) XXX_DiscardUnknown() {
	xxx_messageInfo_Item.DiscardUnknown(m)
}

var xxx_messageInfo_Item proto.InternalMessageInfo

func (m *Item) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Item) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Item) GetTarget() Target {
	if m != nil {
		return m.Target
	}
	return Target_Self
}

func (m *Item) GetPassive() bool {
	if m != nil {
		return m.Passive
	}
	return false
}

func (m *Item) GetBonus() map[string]int32 {
	if m != nil {
		return m.Bonus
	}
	return nil
}

func (m *Item) GetCount() int32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *Item) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Item) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Creature is the base stats shared by characters and monsters
type Creature struct {
	// Id is the UUID for the creature
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name is the human readable name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// MaxHp is the maximum amount of HP the creature can have
	MaxHp int32 `protobuf:"varint,3,opt,name=max_hp,json=maxHp,proto3" json:"max_hp,omitempty"`
	// CurHp is the current HP value
	CurHp int32 `protobuf:"varint,4,opt,name=cur_hp,json=curHp,proto3" json:"cur_hp,omitempty"`
	// Position deetermines what threat zone the creature is currently standing in
	Position Position `protobuf:"varint,5,opt,name=position,proto3,enum=endless.stream.v1.Position" json:"position,omitempty"`
	// Statuses is a list of effects that currently affect this creature.
	Statuses             []StatusEffect `protobuf:"varint,6,rep,packed,name=statuses,proto3,enum=endless.stream.v1.StatusEffect" json:"statuses,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *Creature) Reset()         { *m = Creature{} }
func (m *Creature) String() string { return proto.CompactTextString(m) }
func (*Creature) ProtoMessage()    {}
func (*Creature) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{2}
}

func (m *Creature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Creature.Unmarshal(m, b)
}
func (m *Creature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Creature.Marshal(b, m, deterministic)
}
func (m *Creature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Creature.Merge(m, src)
}
func (m *Creature) XXX_Size() int {
	return xxx_messageInfo_Creature.Size(m)
}
func (m *Creature) XXX_DiscardUnknown() {
	xxx_messageInfo_Creature.DiscardUnknown(m)
}

var xxx_messageInfo_Creature proto.InternalMessageInfo

func (m *Creature) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Creature) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Creature) GetMaxHp() int32 {
	if m != nil {
		return m.MaxHp
	}
	return 0
}

func (m *Creature) GetCurHp() int32 {
	if m != nil {
		return m.CurHp
	}
	return 0
}

func (m *Creature) GetPosition() Position {
	if m != nil {
		return m.Position
	}
	return Position_PlayerSide
}

func (m *Creature) GetStatuses() []StatusEffect {
	if m != nil {
		return m.Statuses
	}
	return nil
}

// Player represents a user or AI controlled character
type Player struct {
	// Base is the basic stats of the player
	Base *Creature `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	// Character is what class the player is playing as (or if they're the status screen or an audience member)
	Character Class `protobuf:"varint,2,opt,name=character,proto3,enum=endless.stream.v1.Class" json:"character,omitempty"`
	// IsAI is true if this player is currently controlled by an AI
	IsAi bool `protobuf:"varint,3,opt,name=is_ai,json=isAi,proto3" json:"is_ai,omitempty"`
	// Level is their current character level, starts at 1
	Level int32 `protobuf:"varint,4,opt,name=level,proto3" json:"level,omitempty"`
	// Skills is a map of ID to skill
	Skills map[string]*Skill `protobuf:"bytes,5,rep,name=skills,proto3" json:"skills,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Inventory is a map of ID to items currently held by this player
	Inventory            map[string]*Item `protobuf:"bytes,6,rep,name=inventory,proto3" json:"inventory,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Strength             int32            `protobuf:"varint,20,opt,name=strength,proto3" json:"strength,omitempty"`
	Vitality             int32            `protobuf:"varint,21,opt,name=vitality,proto3" json:"vitality,omitempty"`
	CombatDamageBase     int32            `protobuf:"varint,22,opt,name=combat_damage_base,json=combatDamageBase,proto3" json:"combat_damage_base,omitempty"`
	VitalityRegen        int32            `protobuf:"varint,23,opt,name=vitality_regen,json=vitalityRegen,proto3" json:"vitality_regen,omitempty"`
	Intelligence         int32            `protobuf:"varint,30,opt,name=intelligence,proto3" json:"intelligence,omitempty"`
	Focus                int32            `protobuf:"varint,31,opt,name=focus,proto3" json:"focus,omitempty"`
	Willpower            int32            `protobuf:"varint,32,opt,name=willpower,proto3" json:"willpower,omitempty"`
	FocusRegen           int32            `protobuf:"varint,33,opt,name=focus_regen,json=focusRegen,proto3" json:"focus_regen,omitempty"`
	Agility              int32            `protobuf:"varint,40,opt,name=agility,proto3" json:"agility,omitempty"`
	Evasion              int32            `protobuf:"varint,41,opt,name=evasion,proto3" json:"evasion,omitempty"`
	Accuracy             int32            `protobuf:"varint,42,opt,name=accuracy,proto3" json:"accuracy,omitempty"`
	Initiative           int32            `protobuf:"varint,43,opt,name=initiative,proto3" json:"initiative,omitempty"`
	Gold                 int64            `protobuf:"varint,50,opt,name=gold,proto3" json:"gold,omitempty"`
	Xp                   int64            `protobuf:"varint,51,opt,name=xp,proto3" json:"xp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Player) Reset()         { *m = Player{} }
func (m *Player) String() string { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()    {}
func (*Player) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{3}
}

func (m *Player) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Player.Unmarshal(m, b)
}
func (m *Player) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Player.Marshal(b, m, deterministic)
}
func (m *Player) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Player.Merge(m, src)
}
func (m *Player) XXX_Size() int {
	return xxx_messageInfo_Player.Size(m)
}
func (m *Player) XXX_DiscardUnknown() {
	xxx_messageInfo_Player.DiscardUnknown(m)
}

var xxx_messageInfo_Player proto.InternalMessageInfo

func (m *Player) GetBase() *Creature {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *Player) GetCharacter() Class {
	if m != nil {
		return m.Character
	}
	return Class_Unknown
}

func (m *Player) GetIsAi() bool {
	if m != nil {
		return m.IsAi
	}
	return false
}

func (m *Player) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Player) GetSkills() map[string]*Skill {
	if m != nil {
		return m.Skills
	}
	return nil
}

func (m *Player) GetInventory() map[string]*Item {
	if m != nil {
		return m.Inventory
	}
	return nil
}

func (m *Player) GetStrength() int32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

func (m *Player) GetVitality() int32 {
	if m != nil {
		return m.Vitality
	}
	return 0
}

func (m *Player) GetCombatDamageBase() int32 {
	if m != nil {
		return m.CombatDamageBase
	}
	return 0
}

func (m *Player) GetVitalityRegen() int32 {
	if m != nil {
		return m.VitalityRegen
	}
	return 0
}

func (m *Player) GetIntelligence() int32 {
	if m != nil {
		return m.Intelligence
	}
	return 0
}

func (m *Player) GetFocus() int32 {
	if m != nil {
		return m.Focus
	}
	return 0
}

func (m *Player) GetWillpower() int32 {
	if m != nil {
		return m.Willpower
	}
	return 0
}

func (m *Player) GetFocusRegen() int32 {
	if m != nil {
		return m.FocusRegen
	}
	return 0
}

func (m *Player) GetAgility() int32 {
	if m != nil {
		return m.Agility
	}
	return 0
}

func (m *Player) GetEvasion() int32 {
	if m != nil {
		return m.Evasion
	}
	return 0
}

func (m *Player) GetAccuracy() int32 {
	if m != nil {
		return m.Accuracy
	}
	return 0
}

func (m *Player) GetInitiative() int32 {
	if m != nil {
		return m.Initiative
	}
	return 0
}

func (m *Player) GetGold() int64 {
	if m != nil {
		return m.Gold
	}
	return 0
}

func (m *Player) GetXp() int64 {
	if m != nil {
		return m.Xp
	}
	return 0
}

// Monster represents an enemy the characters are fighting
type Monster struct {
	Base                 *Creature `protobuf:"bytes,1,opt,name=base,proto3" json:"base,omitempty"`
	Type                 Type      `protobuf:"varint,3,opt,name=type,proto3,enum=endless.stream.v1.Type" json:"type,omitempty"`
	IsFlying             bool      `protobuf:"varint,4,opt,name=is_flying,json=isFlying,proto3" json:"is_flying,omitempty"`
	IsBoss               bool      `protobuf:"varint,5,opt,name=is_boss,json=isBoss,proto3" json:"is_boss,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *Monster) Reset()         { *m = Monster{} }
func (m *Monster) String() string { return proto.CompactTextString(m) }
func (*Monster) ProtoMessage()    {}
func (*Monster) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{4}
}

func (m *Monster) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Monster.Unmarshal(m, b)
}
func (m *Monster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Monster.Marshal(b, m, deterministic)
}
func (m *Monster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Monster.Merge(m, src)
}
func (m *Monster) XXX_Size() int {
	return xxx_messageInfo_Monster.Size(m)
}
func (m *Monster) XXX_DiscardUnknown() {
	xxx_messageInfo_Monster.DiscardUnknown(m)
}

var xxx_messageInfo_Monster proto.InternalMessageInfo

func (m *Monster) GetBase() *Creature {
	if m != nil {
		return m.Base
	}
	return nil
}

func (m *Monster) GetType() Type {
	if m != nil {
		return m.Type
	}
	return Type_None
}

func (m *Monster) GetIsFlying() bool {
	if m != nil {
		return m.IsFlying
	}
	return false
}

func (m *Monster) GetIsBoss() bool {
	if m != nil {
		return m.IsBoss
	}
	return false
}

// EventMessage is used when the game needs to display a message in the UI
type EventMessage struct {
	// MsgId is the id of the message
	MsgId int32 `protobuf:"varint,1,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	// Msg contains the message content
	Msg string `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	// IsError is true if the message is about an error that has occured
	IsError bool `protobuf:"varint,3,opt,name=is_error,json=isError,proto3" json:"is_error,omitempty"`
	// IsAlert is true if the message is an alert, and only has an "Ok" button.
	// False means it's a confirmation, which has an "Yes" & "No" button
	IsAlert bool `protobuf:"varint,4,opt,name=is_alert,json=isAlert,proto3" json:"is_alert,omitempty"`
	// PlayerId is set only if the message is for a specific player.
	PlayerId *wrappers.StringValue `protobuf:"bytes,5,opt,name=player_id,json=playerId,proto3" json:"player_id,omitempty"`
	// LogOnly is a boolean that if true, messages go into the player log without
	// getting any kind of notification
	LogOnly              bool     `protobuf:"varint,6,opt,name=log_only,json=logOnly,proto3" json:"log_only,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EventMessage) Reset()         { *m = EventMessage{} }
func (m *EventMessage) String() string { return proto.CompactTextString(m) }
func (*EventMessage) ProtoMessage()    {}
func (*EventMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{5}
}

func (m *EventMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventMessage.Unmarshal(m, b)
}
func (m *EventMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventMessage.Marshal(b, m, deterministic)
}
func (m *EventMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMessage.Merge(m, src)
}
func (m *EventMessage) XXX_Size() int {
	return xxx_messageInfo_EventMessage.Size(m)
}
func (m *EventMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMessage.DiscardUnknown(m)
}

var xxx_messageInfo_EventMessage proto.InternalMessageInfo

func (m *EventMessage) GetMsgId() int32 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *EventMessage) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *EventMessage) GetIsError() bool {
	if m != nil {
		return m.IsError
	}
	return false
}

func (m *EventMessage) GetIsAlert() bool {
	if m != nil {
		return m.IsAlert
	}
	return false
}

func (m *EventMessage) GetPlayerId() *wrappers.StringValue {
	if m != nil {
		return m.PlayerId
	}
	return nil
}

func (m *EventMessage) GetLogOnly() bool {
	if m != nil {
		return m.LogOnly
	}
	return false
}

// CharacterSelected is sent by the game when someone selects a character
// on the character selection screen. This is used to disable that character in the UI
// so nobody else can select it.
type CharacterSelected struct {
	// Selected is a map of ID -> class
	Selected             map[string]Class `protobuf:"bytes,1,rep,name=selected,proto3" json:"selected,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3,enum=endless.stream.v1.Class"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *CharacterSelected) Reset()         { *m = CharacterSelected{} }
func (m *CharacterSelected) String() string { return proto.CompactTextString(m) }
func (*CharacterSelected) ProtoMessage()    {}
func (*CharacterSelected) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{6}
}

func (m *CharacterSelected) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CharacterSelected.Unmarshal(m, b)
}
func (m *CharacterSelected) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CharacterSelected.Marshal(b, m, deterministic)
}
func (m *CharacterSelected) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CharacterSelected.Merge(m, src)
}
func (m *CharacterSelected) XXX_Size() int {
	return xxx_messageInfo_CharacterSelected.Size(m)
}
func (m *CharacterSelected) XXX_DiscardUnknown() {
	xxx_messageInfo_CharacterSelected.DiscardUnknown(m)
}

var xxx_messageInfo_CharacterSelected proto.InternalMessageInfo

func (m *CharacterSelected) GetSelected() map[string]Class {
	if m != nil {
		return m.Selected
	}
	return nil
}

// Wave has some basic information about the wave
type Wave struct {
	Num                  int32    `protobuf:"varint,1,opt,name=num,proto3" json:"num,omitempty"`
	HasBoss              bool     `protobuf:"varint,2,opt,name=has_boss,json=hasBoss,proto3" json:"has_boss,omitempty"`
	Level                Level    `protobuf:"varint,3,opt,name=level,proto3,enum=endless.stream.v1.Level" json:"level,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Wave) Reset()         { *m = Wave{} }
func (m *Wave) String() string { return proto.CompactTextString(m) }
func (*Wave) ProtoMessage()    {}
func (*Wave) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{7}
}

func (m *Wave) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Wave.Unmarshal(m, b)
}
func (m *Wave) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Wave.Marshal(b, m, deterministic)
}
func (m *Wave) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Wave.Merge(m, src)
}
func (m *Wave) XXX_Size() int {
	return xxx_messageInfo_Wave.Size(m)
}
func (m *Wave) XXX_DiscardUnknown() {
	xxx_messageInfo_Wave.DiscardUnknown(m)
}

var xxx_messageInfo_Wave proto.InternalMessageInfo

func (m *Wave) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

func (m *Wave) GetHasBoss() bool {
	if m != nil {
		return m.HasBoss
	}
	return false
}

func (m *Wave) GetLevel() Level {
	if m != nil {
		return m.Level
	}
	return Level_Forest
}

// CurrentState is sent after something has happened to change the state.
type CurrentState struct {
	// Monsters holds an array of the monsters in the current wave
	Monsters []*Monster `protobuf:"bytes,1,rep,name=monsters,proto3" json:"monsters,omitempty"`
	// Players contains a list of id->Player of who's in the game currently
	Players map[string]*Player `protobuf:"bytes,2,rep,name=players,proto3" json:"players,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// CurrentPlayer is the UUID of the player whose turn it is currently.
	// If it is null, it is currently a monster's turn or the players aren't in battle ( ie, in the store or all dead ).
	CurrentPlayer *wrappers.StringValue `protobuf:"bytes,3,opt,name=current_player,json=currentPlayer,proto3" json:"current_player,omitempty"`
	// Display indicates what screen the game is on currently. Clients don't have to care about all of these.
	// For example, the player display screen doesn't care about the NewWave display.
	Display Display `protobuf:"varint,4,opt,name=display,proto3,enum=endless.stream.v1.Display" json:"display,omitempty"`
	// CurrentWave is used to indicate what the current wave is
	CurrentWave *Wave `protobuf:"bytes,5,opt,name=current_wave,json=currentWave,proto3" json:"current_wave,omitempty"`
	// UpcomingWaves is used to show an "upcoming waves" tracker on the shared info screen
	UpcomingWaves map[int32]*Wave `protobuf:"bytes,6,rep,name=upcoming_waves,json=upcomingWaves,proto3" json:"upcoming_waves,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// AudienceCount is how many folks are in the active audience ( connected to the current game
	// as an audience member )
	AudienceCount        int32    `protobuf:"varint,7,opt,name=audience_count,json=audienceCount,proto3" json:"audience_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CurrentState) Reset()         { *m = CurrentState{} }
func (m *CurrentState) String() string { return proto.CompactTextString(m) }
func (*CurrentState) ProtoMessage()    {}
func (*CurrentState) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{8}
}

func (m *CurrentState) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CurrentState.Unmarshal(m, b)
}
func (m *CurrentState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CurrentState.Marshal(b, m, deterministic)
}
func (m *CurrentState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CurrentState.Merge(m, src)
}
func (m *CurrentState) XXX_Size() int {
	return xxx_messageInfo_CurrentState.Size(m)
}
func (m *CurrentState) XXX_DiscardUnknown() {
	xxx_messageInfo_CurrentState.DiscardUnknown(m)
}

var xxx_messageInfo_CurrentState proto.InternalMessageInfo

func (m *CurrentState) GetMonsters() []*Monster {
	if m != nil {
		return m.Monsters
	}
	return nil
}

func (m *CurrentState) GetPlayers() map[string]*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

func (m *CurrentState) GetCurrentPlayer() *wrappers.StringValue {
	if m != nil {
		return m.CurrentPlayer
	}
	return nil
}

func (m *CurrentState) GetDisplay() Display {
	if m != nil {
		return m.Display
	}
	return Display_CharacterSelect
}

func (m *CurrentState) GetCurrentWave() *Wave {
	if m != nil {
		return m.CurrentWave
	}
	return nil
}

func (m *CurrentState) GetUpcomingWaves() map[int32]*Wave {
	if m != nil {
		return m.UpcomingWaves
	}
	return nil
}

func (m *CurrentState) GetAudienceCount() int32 {
	if m != nil {
		return m.AudienceCount
	}
	return 0
}

// Tick is a message that's sent out on a set schedule
// that informs things like countdown timers and whatnot
type Tick struct {
	// Time is just so that the game clients can ignore ticks from too far in the past
	Time *timestamp.Timestamp `protobuf:"bytes,1,opt,name=time,proto3" json:"time,omitempty"`
	// Progress is null if there is no progress bar, but if it's present it counts from 100 down to 0
	// so that the clients know that there is a countdown in progress ( such as the game saying that
	// it's about to make a descision for a player in battle, or that the store is about to go away, etc)
	Progress             *wrappers.Int32Value `protobuf:"bytes,2,opt,name=progress,proto3" json:"progress,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Tick) Reset()         { *m = Tick{} }
func (m *Tick) String() string { return proto.CompactTextString(m) }
func (*Tick) ProtoMessage()    {}
func (*Tick) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{9}
}

func (m *Tick) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Tick.Unmarshal(m, b)
}
func (m *Tick) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Tick.Marshal(b, m, deterministic)
}
func (m *Tick) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tick.Merge(m, src)
}
func (m *Tick) XXX_Size() int {
	return xxx_messageInfo_Tick.Size(m)
}
func (m *Tick) XXX_DiscardUnknown() {
	xxx_messageInfo_Tick.DiscardUnknown(m)
}

var xxx_messageInfo_Tick proto.InternalMessageInfo

func (m *Tick) GetTime() *timestamp.Timestamp {
	if m != nil {
		return m.Time
	}
	return nil
}

func (m *Tick) GetProgress() *wrappers.Int32Value {
	if m != nil {
		return m.Progress
	}
	return nil
}

type JoinedGame struct {
	// Id is the UUID of the player
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// AsAudience lets the client know if the player has joined as one of the four main or if they
	// have joined as part of the audience
	AsAudience bool `protobuf:"varint,2,opt,name=as_audience,json=asAudience,proto3" json:"as_audience,omitempty"`
	// IsVIP is to indicate if the player is "player 1", ie, they're the player
	// that gets to make decisions like when to start the game
	IsVip bool `protobuf:"varint,3,opt,name=is_vip,json=isVip,proto3" json:"is_vip,omitempty"`
	// Name is the name of the player
	Name                 string   `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *JoinedGame) Reset()         { *m = JoinedGame{} }
func (m *JoinedGame) String() string { return proto.CompactTextString(m) }
func (*JoinedGame) ProtoMessage()    {}
func (*JoinedGame) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{10}
}

func (m *JoinedGame) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_JoinedGame.Unmarshal(m, b)
}
func (m *JoinedGame) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_JoinedGame.Marshal(b, m, deterministic)
}
func (m *JoinedGame) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JoinedGame.Merge(m, src)
}
func (m *JoinedGame) XXX_Size() int {
	return xxx_messageInfo_JoinedGame.Size(m)
}
func (m *JoinedGame) XXX_DiscardUnknown() {
	xxx_messageInfo_JoinedGame.DiscardUnknown(m)
}

var xxx_messageInfo_JoinedGame proto.InternalMessageInfo

func (m *JoinedGame) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *JoinedGame) GetAsAudience() bool {
	if m != nil {
		return m.AsAudience
	}
	return false
}

func (m *JoinedGame) GetIsVip() bool {
	if m != nil {
		return m.IsVip
	}
	return false
}

func (m *JoinedGame) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Action is sent when an actor in the game does something ( attacks a target, uses a skill, etc ),
// that requires the UI ( player or status ) to display something.
type Action struct {
	// Id is a UUID, and should be used in the ActionComplete message
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// ActorId is the UUID of the actor performing the action
	ActorId string `protobuf:"bytes,2,opt,name=actor_id,json=actorId,proto3" json:"actor_id,omitempty"`
	// TargetIds is the UUID of the target of the action. It may be empty if the action
	// has no target ( ie, a move action ).
	TargetIds []string `protobuf:"bytes,3,rep,name=target_ids,json=targetIds,proto3" json:"target_ids,omitempty"`
	// Msg is a human readable message of what the action is, such as "Bob hits the Kobold with Divine Strike
	// for 10 points of damage"
	Msg string `protobuf:"bytes,4,opt,name=msg,proto3" json:"msg,omitempty"`
	// Skill is the skill used
	Skill *Skill `protobuf:"bytes,6,opt,name=skill,proto3" json:"skill,omitempty"`
	// Value is the amount of damage ( or healing ) done by the skill
	Value                int32    `protobuf:"varint,7,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}
func (*Action) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{11}
}

func (m *Action) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Action.Unmarshal(m, b)
}
func (m *Action) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Action.Marshal(b, m, deterministic)
}
func (m *Action) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Action.Merge(m, src)
}
func (m *Action) XXX_Size() int {
	return xxx_messageInfo_Action.Size(m)
}
func (m *Action) XXX_DiscardUnknown() {
	xxx_messageInfo_Action.DiscardUnknown(m)
}

var xxx_messageInfo_Action proto.InternalMessageInfo

func (m *Action) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Action) GetActorId() string {
	if m != nil {
		return m.ActorId
	}
	return ""
}

func (m *Action) GetTargetIds() []string {
	if m != nil {
		return m.TargetIds
	}
	return nil
}

func (m *Action) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Action) GetSkill() *Skill {
	if m != nil {
		return m.Skill
	}
	return nil
}

func (m *Action) GetValue() int32 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Sent when the players enter the store, contains the inventory & prices of
// what's in the store
type StoreInventory struct {
	// Inventory is a map of UUID -> Item of what's in the store
	Inventory map[string]*Item `protobuf:"bytes,1,rep,name=inventory,proto3" json:"inventory,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Prices is a map of UUID -> price of what's in the store
	Prices               map[string]int32 `protobuf:"bytes,2,rep,name=prices,proto3" json:"prices,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *StoreInventory) Reset()         { *m = StoreInventory{} }
func (m *StoreInventory) String() string { return proto.CompactTextString(m) }
func (*StoreInventory) ProtoMessage()    {}
func (*StoreInventory) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{12}
}

func (m *StoreInventory) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StoreInventory.Unmarshal(m, b)
}
func (m *StoreInventory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StoreInventory.Marshal(b, m, deterministic)
}
func (m *StoreInventory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreInventory.Merge(m, src)
}
func (m *StoreInventory) XXX_Size() int {
	return xxx_messageInfo_StoreInventory.Size(m)
}
func (m *StoreInventory) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreInventory.DiscardUnknown(m)
}

var xxx_messageInfo_StoreInventory proto.InternalMessageInfo

func (m *StoreInventory) GetInventory() map[string]*Item {
	if m != nil {
		return m.Inventory
	}
	return nil
}

func (m *StoreInventory) GetPrices() map[string]int32 {
	if m != nil {
		return m.Prices
	}
	return nil
}

// Output is sent by the game server to update clients on various parts of the game
type Output struct {
	// Types that are valid to be assigned to Data:
	//	*Output_State
	//	*Output_Joined
	//	*Output_Tick
	//	*Output_Msg
	//	*Output_Action
	//	*Output_Selected
	//	*Output_StoreInventory
	Data                 isOutput_Data `protobuf_oneof:"data"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Output) Reset()         { *m = Output{} }
func (m *Output) String() string { return proto.CompactTextString(m) }
func (*Output) ProtoMessage()    {}
func (*Output) Descriptor() ([]byte, []int) {
	return fileDescriptor_0b2b3ae2e703b013, []int{13}
}

func (m *Output) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Output.Unmarshal(m, b)
}
func (m *Output) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Output.Marshal(b, m, deterministic)
}
func (m *Output) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Output.Merge(m, src)
}
func (m *Output) XXX_Size() int {
	return xxx_messageInfo_Output.Size(m)
}
func (m *Output) XXX_DiscardUnknown() {
	xxx_messageInfo_Output.DiscardUnknown(m)
}

var xxx_messageInfo_Output proto.InternalMessageInfo

type isOutput_Data interface {
	isOutput_Data()
}

type Output_State struct {
	State *CurrentState `protobuf:"bytes,1,opt,name=state,proto3,oneof"`
}

type Output_Joined struct {
	Joined *JoinedGame `protobuf:"bytes,2,opt,name=joined,proto3,oneof"`
}

type Output_Tick struct {
	Tick *Tick `protobuf:"bytes,3,opt,name=tick,proto3,oneof"`
}

type Output_Msg struct {
	Msg *EventMessage `protobuf:"bytes,4,opt,name=msg,proto3,oneof"`
}

type Output_Action struct {
	Action *Action `protobuf:"bytes,5,opt,name=action,proto3,oneof"`
}

type Output_Selected struct {
	Selected *CharacterSelected `protobuf:"bytes,6,opt,name=selected,proto3,oneof"`
}

type Output_StoreInventory struct {
	StoreInventory *StoreInventory `protobuf:"bytes,7,opt,name=store_inventory,json=storeInventory,proto3,oneof"`
}

func (*Output_State) isOutput_Data() {}

func (*Output_Joined) isOutput_Data() {}

func (*Output_Tick) isOutput_Data() {}

func (*Output_Msg) isOutput_Data() {}

func (*Output_Action) isOutput_Data() {}

func (*Output_Selected) isOutput_Data() {}

func (*Output_StoreInventory) isOutput_Data() {}

func (m *Output) GetData() isOutput_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Output) GetState() *CurrentState {
	if x, ok := m.GetData().(*Output_State); ok {
		return x.State
	}
	return nil
}

func (m *Output) GetJoined() *JoinedGame {
	if x, ok := m.GetData().(*Output_Joined); ok {
		return x.Joined
	}
	return nil
}

func (m *Output) GetTick() *Tick {
	if x, ok := m.GetData().(*Output_Tick); ok {
		return x.Tick
	}
	return nil
}

func (m *Output) GetMsg() *EventMessage {
	if x, ok := m.GetData().(*Output_Msg); ok {
		return x.Msg
	}
	return nil
}

func (m *Output) GetAction() *Action {
	if x, ok := m.GetData().(*Output_Action); ok {
		return x.Action
	}
	return nil
}

func (m *Output) GetSelected() *CharacterSelected {
	if x, ok := m.GetData().(*Output_Selected); ok {
		return x.Selected
	}
	return nil
}

func (m *Output) GetStoreInventory() *StoreInventory {
	if x, ok := m.GetData().(*Output_StoreInventory); ok {
		return x.StoreInventory
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Output) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Output_State)(nil),
		(*Output_Joined)(nil),
		(*Output_Tick)(nil),
		(*Output_Msg)(nil),
		(*Output_Action)(nil),
		(*Output_Selected)(nil),
		(*Output_StoreInventory)(nil),
	}
}

func init() {
	proto.RegisterEnum("endless.stream.v1.Target", Target_name, Target_value)
	proto.RegisterEnum("endless.stream.v1.Position", Position_name, Position_value)
	proto.RegisterType((*Skill)(nil), "endless.stream.v1.Skill")
	proto.RegisterType((*Item)(nil), "endless.stream.v1.Item")
	proto.RegisterMapType((map[string]int32)(nil), "endless.stream.v1.Item.BonusEntry")
	proto.RegisterType((*Creature)(nil), "endless.stream.v1.Creature")
	proto.RegisterType((*Player)(nil), "endless.stream.v1.Player")
	proto.RegisterMapType((map[string]*Item)(nil), "endless.stream.v1.Player.InventoryEntry")
	proto.RegisterMapType((map[string]*Skill)(nil), "endless.stream.v1.Player.SkillsEntry")
	proto.RegisterType((*Monster)(nil), "endless.stream.v1.Monster")
	proto.RegisterType((*EventMessage)(nil), "endless.stream.v1.EventMessage")
	proto.RegisterType((*CharacterSelected)(nil), "endless.stream.v1.CharacterSelected")
	proto.RegisterMapType((map[string]Class)(nil), "endless.stream.v1.CharacterSelected.SelectedEntry")
	proto.RegisterType((*Wave)(nil), "endless.stream.v1.Wave")
	proto.RegisterType((*CurrentState)(nil), "endless.stream.v1.CurrentState")
	proto.RegisterMapType((map[string]*Player)(nil), "endless.stream.v1.CurrentState.PlayersEntry")
	proto.RegisterMapType((map[int32]*Wave)(nil), "endless.stream.v1.CurrentState.UpcomingWavesEntry")
	proto.RegisterType((*Tick)(nil), "endless.stream.v1.Tick")
	proto.RegisterType((*JoinedGame)(nil), "endless.stream.v1.JoinedGame")
	proto.RegisterType((*Action)(nil), "endless.stream.v1.Action")
	proto.RegisterType((*StoreInventory)(nil), "endless.stream.v1.StoreInventory")
	proto.RegisterMapType((map[string]*Item)(nil), "endless.stream.v1.StoreInventory.InventoryEntry")
	proto.RegisterMapType((map[string]int32)(nil), "endless.stream.v1.StoreInventory.PricesEntry")
	proto.RegisterType((*Output)(nil), "endless.stream.v1.Output")
}

func init() { proto.RegisterFile("output.proto", fileDescriptor_0b2b3ae2e703b013) }

var fileDescriptor_0b2b3ae2e703b013 = []byte{
	// 1722 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x51, 0x73, 0xdb, 0xc6,
	0x11, 0x16, 0x49, 0x10, 0x24, 0x97, 0x12, 0xab, 0x5c, 0x93, 0x18, 0x66, 0x12, 0x4b, 0x61, 0x9b,
	0x19, 0xd5, 0x89, 0xa9, 0x86, 0x6a, 0x6a, 0x27, 0x9d, 0x3e, 0x48, 0x8a, 0x5c, 0xa9, 0x63, 0xc7,
	0x1e, 0xc8, 0x4e, 0x27, 0x7d, 0xc1, 0x1c, 0x81, 0x13, 0x78, 0x15, 0x88, 0xc3, 0xe0, 0x0e, 0x94,
	0xf9, 0x63, 0xfa, 0xd4, 0xb7, 0xce, 0xf4, 0x07, 0xb4, 0x7d, 0xec, 0x3f, 0xe8, 0xbf, 0xe8, 0x4f,
	0xe8, 0x5b, 0xe7, 0xf6, 0x0e, 0x22, 0x24, 0x43, 0x96, 0xda, 0x99, 0xbe, 0xdd, 0xee, 0xed, 0xee,
	0xdd, 0x7d, 0xd8, 0xfd, 0x76, 0x01, 0xeb, 0xa2, 0x50, 0x59, 0xa1, 0xc6, 0x59, 0x2e, 0x94, 0x20,
	0xef, 0xb1, 0x34, 0x4a, 0x98, 0x94, 0x63, 0xa9, 0x72, 0x46, 0xe7, 0xe3, 0xc5, 0x97, 0xc3, 0x07,
	0xb1, 0x10, 0x71, 0xc2, 0x76, 0xd1, 0x60, 0x5a, 0x9c, 0xed, 0x5e, 0xe4, 0x34, 0xcb, 0x58, 0x2e,
	0x8d, 0xcb, 0x70, 0xeb, 0xfa, 0xbe, 0xe2, 0x73, 0x26, 0x15, 0x9d, 0x67, 0xd6, 0x00, 0x0a, 0xc5,
	0x13, 0xb3, 0x1e, 0xfd, 0xa9, 0x09, 0xed, 0xd3, 0x73, 0x9e, 0x24, 0x64, 0x00, 0x4d, 0x1e, 0x79,
	0x8d, 0xed, 0xc6, 0x4e, 0xcf, 0x6f, 0xf2, 0x88, 0x10, 0x70, 0x52, 0x3a, 0x67, 0x5e, 0x13, 0x35,
	0xb8, 0x26, 0xef, 0x43, 0x3b, 0x61, 0x0b, 0x96, 0x78, 0xad, 0xed, 0xc6, 0x4e, 0xdb, 0x37, 0x02,
	0xf9, 0x12, 0x5c, 0x45, 0xf3, 0x98, 0x29, 0xcf, 0xd9, 0x6e, 0xec, 0x0c, 0x26, 0xf7, 0xc7, 0x6f,
	0x5d, 0x7a, 0xfc, 0x0a, 0x0d, 0x7c, 0x6b, 0xa8, 0x83, 0x87, 0x42, 0x2a, 0xaf, 0x8d, 0x71, 0x70,
	0x4d, 0x86, 0xd0, 0x0d, 0x85, 0x48, 0x22, 0x71, 0x91, 0x7a, 0x2e, 0xea, 0x2f, 0x65, 0xf2, 0x13,
	0xd8, 0x28, 0xd7, 0x41, 0xc2, 0xce, 0x94, 0xd7, 0x41, 0x83, 0xf5, 0x52, 0xf9, 0x8c, 0x9d, 0x29,
	0xf2, 0x21, 0xb8, 0x34, 0x54, 0x7c, 0xc1, 0xbc, 0xee, 0x76, 0x63, 0xa7, 0xeb, 0x5b, 0x89, 0x3c,
	0x00, 0x28, 0xb2, 0x38, 0xa7, 0x11, 0x9d, 0x26, 0xcc, 0xeb, 0xe1, 0x5e, 0x45, 0x43, 0xb6, 0xa1,
	0x1f, 0x31, 0x19, 0xe6, 0x3c, 0x53, 0x5c, 0xa4, 0xde, 0x04, 0x1f, 0x5c, 0x55, 0x8d, 0xfe, 0xde,
	0x04, 0xe7, 0x44, 0xb1, 0xf9, 0x9d, 0x40, 0x5a, 0xc1, 0xd1, 0xba, 0x2b, 0x1c, 0x1e, 0x74, 0x32,
	0x2a, 0xa5, 0xbe, 0xba, 0x83, 0xd7, 0x2b, 0x45, 0xf2, 0x04, 0xda, 0x53, 0x91, 0x16, 0xd2, 0x73,
	0xb7, 0x5b, 0x3b, 0xfd, 0xc9, 0xa8, 0x26, 0x96, 0xbe, 0xd8, 0xf8, 0x40, 0x1b, 0x1d, 0xa5, 0x2a,
	0x5f, 0xfa, 0xc6, 0x41, 0x7f, 0xab, 0x50, 0x14, 0x69, 0x09, 0x95, 0x11, 0x6e, 0xc4, 0xe8, 0x56,
	0x0c, 0x86, 0x4f, 0x00, 0x56, 0x87, 0x90, 0x4d, 0x68, 0x9d, 0xb3, 0xa5, 0x45, 0x42, 0x2f, 0xf5,
	0x79, 0x0b, 0x9a, 0x14, 0x06, 0x8b, 0xb6, 0x6f, 0x84, 0x6f, 0x9a, 0x4f, 0x1a, 0xa3, 0x7f, 0x36,
	0xa0, 0x7b, 0x98, 0x33, 0xaa, 0x8a, 0x9c, 0xdd, 0x09, 0xc1, 0x0f, 0xc0, 0x9d, 0xd3, 0x37, 0xc1,
	0x2c, 0x2b, 0xf3, 0x6c, 0x4e, 0xdf, 0x1c, 0x67, 0x5a, 0x1d, 0x16, 0xb9, 0x56, 0x3b, 0xf6, 0x49,
	0x45, 0x7e, 0x9c, 0x91, 0xc7, 0xd0, 0xcd, 0x84, 0xe4, 0x78, 0xef, 0x36, 0x22, 0xfe, 0x51, 0x0d,
	0x4a, 0x2f, 0xad, 0x89, 0x7f, 0x69, 0x4c, 0x7e, 0x05, 0x5d, 0xa9, 0xa8, 0x2a, 0x24, 0x33, 0xf0,
	0x0e, 0x26, 0x5b, 0x35, 0x8e, 0xa7, 0x68, 0x72, 0x74, 0x76, 0xc6, 0x42, 0xe5, 0x5f, 0x3a, 0x8c,
	0xfe, 0xe5, 0x82, 0xfb, 0x32, 0xa1, 0x4b, 0x96, 0x93, 0x5d, 0x70, 0xa6, 0x54, 0x32, 0x7c, 0x54,
	0xbf, 0xf6, 0xf0, 0xf2, 0xf5, 0x3e, 0x1a, 0x92, 0x5f, 0x42, 0x2f, 0x9c, 0xd1, 0x9c, 0x86, 0x8a,
	0xe5, 0xf8, 0xf0, 0xc1, 0xc4, 0xab, 0xf3, 0x4a, 0xa8, 0x94, 0xfe, 0xca, 0x94, 0xfc, 0x18, 0xda,
	0x5c, 0x06, 0x94, 0x23, 0x2c, 0x5d, 0xdf, 0xe1, 0x72, 0x9f, 0xaf, 0x6a, 0xd2, 0xa9, 0xd6, 0xe4,
	0xaf, 0xc1, 0x95, 0xba, 0xac, 0xa5, 0xd7, 0xc6, 0xc4, 0xf9, 0xac, 0x0e, 0x12, 0xbc, 0xfe, 0x18,
	0xcb, 0xdf, 0xe6, 0x8e, 0x75, 0x22, 0x4f, 0xa1, 0xc7, 0xd3, 0x05, 0x4b, 0x95, 0xc8, 0x97, 0x36,
	0xf5, 0x76, 0x6e, 0x8e, 0x70, 0x52, 0x9a, 0x9a, 0x20, 0x2b, 0x57, 0x5d, 0xd3, 0xda, 0x3a, 0x8d,
	0xd5, 0xcc, 0x7b, 0xdf, 0xd4, 0x74, 0x29, 0xeb, 0xbd, 0x05, 0x57, 0x34, 0xe1, 0x6a, 0xe9, 0x7d,
	0x60, 0xf6, 0x4a, 0x99, 0x7c, 0x01, 0x24, 0x14, 0xf3, 0x29, 0x55, 0x41, 0x44, 0xe7, 0x34, 0x66,
	0x01, 0x02, 0xfc, 0x21, 0x5a, 0x6d, 0x9a, 0x9d, 0x6f, 0x71, 0xe3, 0x40, 0xe3, 0xf9, 0x19, 0x0c,
	0x4a, 0xcf, 0x20, 0x67, 0x31, 0x4b, 0xbd, 0x7b, 0x68, 0xb9, 0x51, 0x6a, 0x7d, 0xad, 0x24, 0x23,
	0x58, 0xe7, 0xa9, 0x62, 0x49, 0xc2, 0x63, 0x96, 0x86, 0xcc, 0x7b, 0x60, 0x38, 0xa4, 0xaa, 0xd3,
	0x68, 0x9e, 0x89, 0xb0, 0x90, 0xde, 0x96, 0x41, 0x13, 0x05, 0xf2, 0x31, 0xf4, 0x2e, 0x78, 0x92,
	0x64, 0xe2, 0x82, 0xe5, 0xde, 0x36, 0xee, 0xac, 0x14, 0x64, 0x0b, 0xfa, 0x68, 0x66, 0xcf, 0xfe,
	0x14, 0xf7, 0x01, 0x55, 0xe6, 0x60, 0x0f, 0x3a, 0x34, 0xe6, 0xf8, 0xd0, 0x1d, 0xdc, 0x2c, 0x45,
	0xbd, 0xc3, 0x16, 0x54, 0xea, 0xd4, 0xfd, 0x99, 0xd9, 0xb1, 0xa2, 0x46, 0x87, 0x86, 0x61, 0x91,
	0xd3, 0x70, 0xe9, 0x3d, 0x34, 0xe8, 0x94, 0xb2, 0x26, 0x34, 0x9e, 0x72, 0xc5, 0x29, 0x16, 0xf2,
	0xe7, 0xe6, 0xbc, 0x95, 0x46, 0xd7, 0x54, 0x2c, 0x92, 0x08, 0xab, 0xb8, 0xe5, 0xe3, 0x5a, 0xd7,
	0xdd, 0x9b, 0xcc, 0xdb, 0x43, 0x4d, 0xf3, 0x4d, 0x36, 0x3c, 0x85, 0x7e, 0xe5, 0xc3, 0xd7, 0xd4,
	0xf3, 0xb8, 0x5a, 0xcf, 0xfd, 0xda, 0x04, 0xc5, 0x00, 0x95, 0x4a, 0x1f, 0xbe, 0x86, 0xc1, 0xd5,
	0x5c, 0xa8, 0x89, 0xfb, 0xe8, 0x6a, 0xdc, 0x7b, 0x37, 0x30, 0x5a, 0x95, 0x40, 0xfe, 0xd8, 0x80,
	0xce, 0x73, 0x91, 0x4a, 0xf5, 0xbf, 0x14, 0xdb, 0xe7, 0xe0, 0xa8, 0x65, 0xc6, 0x2c, 0x19, 0xd7,
	0x1d, 0xf7, 0x6a, 0x99, 0x31, 0x1f, 0x8d, 0xc8, 0x47, 0xd0, 0xe3, 0x32, 0x38, 0x4b, 0x96, 0x3c,
	0x8d, 0x2d, 0x15, 0x77, 0xb9, 0x7c, 0x8a, 0x32, 0xb9, 0x07, 0x1d, 0x2e, 0x83, 0xa9, 0x90, 0x12,
	0x79, 0xa6, 0xeb, 0xbb, 0x5c, 0x1e, 0x08, 0x29, 0x47, 0xff, 0x68, 0xc0, 0xfa, 0x91, 0x7e, 0xf6,
	0x73, 0x26, 0x25, 0x8d, 0x0d, 0x81, 0xc9, 0x38, 0xb0, 0x44, 0xa7, 0x09, 0x4c, 0xc6, 0x27, 0x91,
	0x06, 0x63, 0x2e, 0x63, 0x4b, 0x75, 0x7a, 0x49, 0xee, 0x43, 0x97, 0xcb, 0x80, 0xe5, 0xb9, 0xc8,
	0x6d, 0x51, 0x77, 0xb8, 0x3c, 0xd2, 0xa2, 0xdd, 0xa2, 0x09, 0xcb, 0x55, 0xd9, 0x14, 0xb8, 0xdc,
	0xd7, 0x22, 0xf9, 0x1a, 0x7a, 0x19, 0x56, 0x9e, 0x3e, 0xa1, 0x8d, 0x40, 0x7c, 0x3c, 0x36, 0x5d,
	0x7f, 0x5c, 0x76, 0xfd, 0xf1, 0xa9, 0xca, 0x79, 0x1a, 0x7f, 0xaf, 0x41, 0xf4, 0xbb, 0xc6, 0xfc,
	0x24, 0xd2, 0x51, 0x13, 0x11, 0x07, 0x22, 0x4d, 0x96, 0xd8, 0x64, 0xbb, 0x7e, 0x27, 0x11, 0xf1,
	0x8b, 0x34, 0x59, 0x8e, 0xfe, 0xd6, 0x80, 0xf7, 0x0e, 0x4b, 0xae, 0x39, 0x65, 0x09, 0x0b, 0x15,
	0x8b, 0xc8, 0x77, 0xd0, 0x95, 0x76, 0xed, 0x35, 0x90, 0x08, 0x26, 0x75, 0x98, 0x5f, 0xf7, 0x1b,
	0x97, 0x0b, 0x43, 0x09, 0x97, 0x31, 0x86, 0xaf, 0x61, 0xe3, 0xca, 0xd6, 0x6d, 0x99, 0xf7, 0x2e,
	0x6a, 0xac, 0xa4, 0x48, 0x08, 0xce, 0xef, 0xe8, 0x82, 0xe9, 0x68, 0x69, 0x31, 0xb7, 0xb0, 0xeb,
	0xa5, 0x7e, 0xf1, 0x8c, 0xda, 0xcf, 0xd6, 0x34, 0x2f, 0x9e, 0x51, 0xfc, 0x6e, 0xfa, 0xa0, 0xd5,
	0x38, 0x53, 0x7f, 0xd0, 0x33, 0xbd, 0x6f, 0x49, 0x75, 0xf4, 0x6f, 0x07, 0xd6, 0x0f, 0x8b, 0x3c,
	0x67, 0xa9, 0xd2, 0x5d, 0x41, 0x13, 0x79, 0x77, 0x6e, 0xf2, 0x52, 0x5a, 0x70, 0x86, 0x35, 0x31,
	0x6c, 0xea, 0xfa, 0x97, 0xb6, 0xe4, 0x29, 0x74, 0xcc, 0x17, 0xd1, 0x57, 0xd2, 0x6e, 0x5f, 0xd4,
	0xbd, 0xb1, 0x72, 0x92, 0x65, 0x5a, 0xcb, 0xd2, 0xa5, 0x33, 0x39, 0x84, 0x41, 0x68, 0xac, 0x02,
	0xa3, 0xc2, 0x97, 0xdc, 0x96, 0x0d, 0x1b, 0xd6, 0xc7, 0xb6, 0xaf, 0x5f, 0x40, 0x27, 0xe2, 0x52,
	0xfb, 0xdb, 0xf9, 0xad, 0xee, 0x0d, 0xdf, 0x1a, 0x0b, 0xbf, 0x34, 0x25, 0xdf, 0xc0, 0x7a, 0x79,
	0xf4, 0x05, 0x5d, 0x30, 0x9b, 0x86, 0x75, 0xe5, 0xa5, 0xbf, 0x8b, 0xdf, 0xb7, 0xc6, 0xf8, 0x91,
	0x7e, 0x80, 0x41, 0x91, 0x85, 0x62, 0xce, 0xd3, 0x18, 0x9d, 0xcb, 0xe9, 0x66, 0x72, 0x1b, 0x0a,
	0xaf, 0xad, 0x97, 0x8e, 0x62, 0xb1, 0xd8, 0x28, 0xaa, 0x3a, 0xdd, 0x0a, 0x68, 0x11, 0x71, 0xcd,
	0xe5, 0x41, 0x75, 0xfc, 0xd9, 0x28, 0xb5, 0x87, 0x5a, 0x39, 0x7c, 0x0d, 0xeb, 0x55, 0x44, 0x6b,
	0x92, 0x70, 0xf7, 0x2a, 0x4d, 0xdd, 0xbf, 0xb1, 0xfb, 0x55, 0xf9, 0xef, 0x07, 0x20, 0x6f, 0x5f,
	0xb1, 0x1a, 0xbc, 0x7d, 0x67, 0x0e, 0x44, 0xd4, 0x2a, 0x09, 0x2e, 0xc0, 0x79, 0xc5, 0xc3, 0x73,
	0x32, 0x06, 0x47, 0xcf, 0xf3, 0x96, 0xff, 0x86, 0x6f, 0x7d, 0xe8, 0x57, 0xe5, 0xb0, 0xef, 0xa3,
	0x1d, 0x4e, 0x47, 0xb9, 0x88, 0x73, 0x66, 0xd3, 0x5f, 0x73, 0xe6, 0x75, 0x9f, 0x93, 0x54, 0xed,
	0x4d, 0x4a, 0xa6, 0xb0, 0xc6, 0xa3, 0x19, 0xc0, 0x6f, 0x05, 0x4f, 0x59, 0xf4, 0x1b, 0x3d, 0x92,
	0x5d, 0x1f, 0xdb, 0xb6, 0xa0, 0x4f, 0x65, 0x50, 0x82, 0x6a, 0x0b, 0x0b, 0xa8, 0xdc, 0xb7, 0x1a,
	0x4d, 0x81, 0x5c, 0x06, 0x0b, 0x9e, 0x59, 0x5e, 0x6b, 0x73, 0xf9, 0x3d, 0xcf, 0x2e, 0xc7, 0x3d,
	0x67, 0x35, 0xee, 0x8d, 0xfe, 0xdc, 0x00, 0x77, 0x3f, 0xc4, 0x91, 0xec, 0xfa, 0x31, 0xf7, 0x75,
	0x17, 0x54, 0x02, 0x89, 0xce, 0xd0, 0x66, 0x07, 0xe5, 0x93, 0x88, 0x7c, 0x02, 0x60, 0xa6, 0xe7,
	0x80, 0x47, 0xd2, 0x6b, 0x6d, 0xb7, 0x76, 0x7a, 0x7e, 0xcf, 0x68, 0x4e, 0x22, 0x59, 0x72, 0xad,
	0xb3, 0xe2, 0xda, 0x31, 0xb4, 0x71, 0xba, 0x41, 0xde, 0x7b, 0x67, 0x43, 0x43, 0xb3, 0xd5, 0x40,
	0xdb, 0xa9, 0x0c, 0xb4, 0xa3, 0xbf, 0x36, 0x61, 0x70, 0xaa, 0x44, 0xce, 0x2e, 0x1b, 0x1d, 0xf9,
	0xae, 0x3a, 0x2c, 0x19, 0x1a, 0xf8, 0x79, 0xed, 0x20, 0x59, 0xf5, 0x7a, 0xc7, 0xd0, 0x74, 0x04,
	0x6e, 0x96, 0xf3, 0x90, 0x95, 0xe4, 0xf0, 0xe8, 0xf6, 0x60, 0x2f, 0xd1, 0xde, 0xce, 0x70, 0xc6,
	0xf9, 0xff, 0xd4, 0x8c, 0x87, 0x5f, 0x43, 0xbf, 0x72, 0xda, 0x7f, 0xf5, 0x23, 0xf0, 0x97, 0x16,
	0xb8, 0x2f, 0xf0, 0xef, 0x96, 0x3c, 0x86, 0xb6, 0x1e, 0xa5, 0xcb, 0x3c, 0xde, 0xba, 0xa5, 0xf2,
	0x8f, 0xd7, 0x7c, 0x63, 0x4f, 0x1e, 0x83, 0xfb, 0x07, 0x4c, 0x4b, 0x7b, 0xe5, 0x4f, 0x6a, 0x3c,
	0x57, 0x79, 0x7b, 0xbc, 0xe6, 0x5b, 0x73, 0xf2, 0x48, 0x17, 0x4e, 0x78, 0x6e, 0x19, 0xb2, 0x76,
	0x0e, 0xe0, 0xe1, 0xf9, 0xf1, 0x9a, 0x8f, 0x66, 0x64, 0x6f, 0x95, 0x3f, 0xf5, 0xd7, 0xab, 0x36,
	0xfc, 0xe3, 0x35, 0x93, 0x62, 0x7b, 0xe6, 0xef, 0xca, 0xfe, 0x88, 0xd4, 0xb3, 0x86, 0xc9, 0x74,
	0x7d, 0x31, 0x63, 0x4a, 0x0e, 0x2a, 0x1d, 0xd6, 0xa4, 0xe6, 0x4f, 0xef, 0xd2, 0x61, 0x8f, 0xd7,
	0x56, 0x5d, 0x95, 0x3c, 0x83, 0x1f, 0x49, 0x9d, 0x11, 0xc1, 0x2a, 0x11, 0x3b, 0x18, 0xea, 0xd3,
	0x5b, 0x73, 0xe7, 0x78, 0xcd, 0x1f, 0xc8, 0x2b, 0x9a, 0x03, 0x17, 0x9c, 0x88, 0x2a, 0xfa, 0x70,
	0x02, 0xae, 0xf9, 0x51, 0x25, 0x5d, 0x70, 0x4e, 0x59, 0x72, 0xb6, 0xb9, 0x46, 0x7a, 0xd0, 0x7e,
	0xce, 0x12, 0xc6, 0x36, 0x1b, 0x04, 0xc0, 0xf5, 0x69, 0x1a, 0xb3, 0x68, 0xb3, 0x49, 0x3a, 0xd0,
	0xda, 0x7f, 0x71, 0xb4, 0xd9, 0x7a, 0xf8, 0x15, 0x74, 0xcb, 0x5f, 0x2d, 0x32, 0x00, 0x30, 0x1c,
	0x79, 0xca, 0x23, 0xb6, 0xb9, 0xa6, 0x1d, 0x9e, 0xf3, 0x28, 0x4a, 0xb4, 0xf3, 0x06, 0xf4, 0x8e,
	0x52, 0x36, 0x5f, 0xe2, 0x56, 0xf3, 0xe0, 0xab, 0xdf, 0xef, 0xc5, 0x5c, 0xcd, 0x8a, 0xe9, 0x38,
	0x14, 0xf3, 0x5d, 0xc9, 0x68, 0x3a, 0xa3, 0x31, 0x4b, 0x77, 0xed, 0xed, 0x03, 0x73, 0xfb, 0xdd,
	0x29, 0x0d, 0xcf, 0x59, 0x1a, 0x95, 0xea, 0xa9, 0x8b, 0x1c, 0xb6, 0xf7, 0x9f, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x67, 0x33, 0xeb, 0x7d, 0x35, 0x11, 0x00, 0x00,
}
