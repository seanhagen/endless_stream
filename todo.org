* Tasks
** TODO Basic Server Setup [1/6]
*** DONE Set up minikube on laptop
CLOSED: [2024-02-19 Mon 15:11]
For local development when not at home. If it takes more than one step, create a
setup script.

*** NEXT Create basic server
Need to create a basic, simple server that's got the Agones SDK set up so that I
can get a handle on game server lifetime stuff. Doesn't need to do much, just a
simple GPRC server with a bi-directional stream that keeps track of how many
clients are connected and marks itself for shutdown/destruction some time after
the last client disconnects.
**** Some architecture stuf
 - folders ( from repo root ) :
   - [ ] /protos => all protobuf definitions
   - [ ] /protos/go => all protobuf generated Go code
   - [ ] /internal/server => defines server, without transport mechanism
   - [ ] /internal/transport/grpc => defines GRPC server that handles GRPC <->
     Game server translation ( hex architecture )
   - [ ] /cmd/overlord => main server binary

**** BACKLOG set up internal server skeleton
Package that defines a basic server, handles connections, messages, etc. The
Agones SDK should be passed in to the constructor ( via config ).

**** BACKLOG set up server command
Binary that sets up dependencies and injects them as part of setting up the
server.

**** BACKLOG build & local deploy process
Magefile target for building the code, and another task ( or tasks ) for
handling doing the Docker build, tagging, and deploying to K8s.

*** BACKLOG Create TUI "game" app
Need a console client so I can test things out without having to create a whole
game build.

*** BACKLOG Set up Turing Pi 2 cluster as kubernetes cluster
Not sure if I want to use the RPi cluster or the other cluster, but either way
get one of the Turing Pi 2 boards set up so that I can install kubernetes on
it.

**** BACKLOG Setup tailscale on kubernetes
Once I get to the point I want to start sending clients to people to test stuff
out, I would rather just test with the Turing Pi cluster. Easiest way to handle
that is probably figuring out how to set up Tailscale with ACLs so that only
specific users/guests have access to it ( or only have access to that and
nothing else )

*** BACKLOG Set up Agones
Figure out good way to install it to a kubernetes cluster. Preferably via some
kind of ops-as-code solution, so that it's super easy to move or set up a new
cluster.

*** TODO Create build pipeline via GitHub Actions
Initially all I need is to run tests, but would be nice to have it set up to do
stuff like:
 - notifies with test results ( via comment, or some other mechanism; preferably
   not publishing a GitHub Page )
 - also runs benchmarks and reports results
 - runs golangci-lint and reports results
 - runs security vulnerability tools ( and reports results )

** BACKLOG DevOps Stuff To Finish Setting Up
*** BACKLOG Magefile target for deploying
Once I've got Agones & Kubernetes set up, need a Magefile target for deploying,
including:

 - [ ] building the docker container
 - [ ] shrinking the docker container
 - [ ] running security tooling on the docker container
 - [ ] uploading the container to a registry
 - [ ] creating an updated k8s/agones configuration
 - [ ] deploying to a dev environment ( turing pi 2 )
 - [ ] deploying to a test environment
 - [ ] deploying to production

*** BACKLOG Magefile target for running other tooling
other than golangci-lint, tests, and security scanning

*** BACKLOG Magefile target for optimizing assets
eventually the server will be serving up assets to the game. need to figure out
how to optimize them.

*** BACKLOG Magefile target for running local server
 - with hot reloading?

* Notes
** How To Test GRPC
*** Servers
The examples use the [[https://github.com/grpc/grpc-go/tree/master/examples/helloworld][helloworld]] protos.

A server is created by doing the following:
#+begin_src go
  s := grpc.NewServer()
	pb.RegisterGreeterServer(s, &server{})
#+end_src

Basically, =grpc.NewServer= creates the type that handles most of the work;
listening for clients, serializing & de-serializing messages, dealing with
errors returned from handlers, etc.

The register function registered the provided type as the implementation of that
server/service.

So to test the server, can just test the handler functions the same as I would
for any other type that has methods.

*** Clients
Clients are defined as interfaces:
#+begin_src go
type HexClient interface {
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	Game(ctx context.Context, opts ...grpc.CallOption) (Hex_GameClient, error)
}
#+end_src

So anything expecting a HexClient can just be passed a type that implements the
correct methods.
