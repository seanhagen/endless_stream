// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: output.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Endless.Stream.V1 {

  /// <summary>Holder for reflection information generated from output.proto</summary>
  public static partial class OutputReflection {

    #region Descriptor
    /// <summary>File descriptor for output.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static OutputReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgxvdXRwdXQucHJvdG8SEWVuZGxlc3Muc3RyZWFtLnYxGh5nb29nbGUvcHJv",
            "dG9idWYvd3JhcHBlcnMucHJvdG8aH2dvb2dsZS9wcm90b2J1Zi90aW1lc3Rh",
            "bXAucHJvdG8aCnV0aWwucHJvdG8iywEKBVNraWxsEgoKAmlkGAEgASgJEgwK",
            "BG5hbWUYAiABKAkSDQoFbGV2ZWwYAyABKAUSKQoGdGFyZ2V0GAQgASgOMhku",
            "ZW5kbGVzcy5zdHJlYW0udjEuVGFyZ2V0EgwKBGNvc3QYBSABKAUSEAoIY29v",
            "bGRvd24YBiABKAUSFQoNY29vbGRvd25fbGVmdBgHIAEoBRIOCgZhY3RpdmUY",
            "CCABKAgSEgoKdXBncmFkYWJsZRgJIAEoCBITCgtkZXNjcmlwdGlvbhgyIAEo",
            "CSLxAQoESXRlbRIKCgJpZBgBIAEoCRIMCgRuYW1lGAIgASgJEikKBnRhcmdl",
            "dBgDIAEoDjIZLmVuZGxlc3Muc3RyZWFtLnYxLlRhcmdldBIPCgdwYXNzaXZl",
            "GAQgASgIEjEKBWJvbnVzGAYgAygLMiIuZW5kbGVzcy5zdHJlYW0udjEuSXRl",
            "bS5Cb251c0VudHJ5Eg0KBWNvdW50GAcgASgFEg4KBmFjdGl2ZRgIIAEoCBIT",
            "CgtkZXNjcmlwdGlvbhgyIAEoCRosCgpCb251c0VudHJ5EgsKA2tleRgBIAEo",
            "CRINCgV2YWx1ZRgCIAEoBToCOAEirQMKCENyZWF0dXJlEgoKAmlkGAEgASgJ",
            "EgwKBG5hbWUYAiABKAkSDgoGbWF4X2hwGAMgASgFEg4KBmN1cl9ocBgEIAEo",
            "BRItCghwb3NpdGlvbhgFIAEoDjIbLmVuZGxlc3Muc3RyZWFtLnYxLlBvc2l0",
            "aW9uEjEKCHN0YXR1c2VzGAYgAygOMh8uZW5kbGVzcy5zdHJlYW0udjEuU3Rh",
            "dHVzRWZmZWN0EhAKCHN0cmVuZ3RoGBQgASgFEhAKCHZpdGFsaXR5GBUgASgF",
            "EhoKEmNvbWJhdF9kYW1hZ2VfYmFzZRgWIAEoBRIWCg52aXRhbGl0eV9yZWdl",
            "bhgXIAEoBRIUCgxpbnRlbGxpZ2VuY2UYHiABKAUSDQoFZm9jdXMYHyABKAUS",
            "EQoJd2lsbHBvd2VyGCAgASgFEhMKC2ZvY3VzX3JlZ2VuGCEgASgFEg8KB2Fn",
            "aWxpdHkYKCABKAUSDwoHZXZhc2lvbhgpIAEoBRIQCghhY2N1cmFjeRgqIAEo",
            "BRISCgppbml0aWF0aXZlGCsgASgFEgwKBGdvbGQYMiABKAMSCgoCeHAYMyAB",
            "KAMihgMKBlBsYXllchIpCgRiYXNlGAEgASgLMhsuZW5kbGVzcy5zdHJlYW0u",
            "djEuQ3JlYXR1cmUSKwoJY2hhcmFjdGVyGAIgASgLMhguZW5kbGVzcy5zdHJl",
            "YW0udjEuQ2xhc3MSDQoFaXNfYWkYAyABKAgSDQoFbGV2ZWwYBCABKAUSNQoG",
            "c2tpbGxzGAUgAygLMiUuZW5kbGVzcy5zdHJlYW0udjEuUGxheWVyLlNraWxs",
            "c0VudHJ5EjsKCWludmVudG9yeRgGIAMoCzIoLmVuZGxlc3Muc3RyZWFtLnYx",
            "LlBsYXllci5JbnZlbnRvcnlFbnRyeRpHCgtTa2lsbHNFbnRyeRILCgNrZXkY",
            "ASABKAkSJwoFdmFsdWUYAiABKAsyGC5lbmRsZXNzLnN0cmVhbS52MS5Ta2ls",
            "bDoCOAEaSQoOSW52ZW50b3J5RW50cnkSCwoDa2V5GAEgASgJEiYKBXZhbHVl",
            "GAIgASgLMhcuZW5kbGVzcy5zdHJlYW0udjEuSXRlbToCOAEifwoHTW9uc3Rl",
            "chIpCgRiYXNlGAEgASgLMhsuZW5kbGVzcy5zdHJlYW0udjEuQ3JlYXR1cmUS",
            "JQoEdHlwZRgDIAEoDjIXLmVuZGxlc3Muc3RyZWFtLnYxLlR5cGUSEQoJaXNf",
            "Zmx5aW5nGAQgASgIEg8KB2lzX2Jvc3MYBSABKAgikgEKDEV2ZW50TWVzc2Fn",
            "ZRIOCgZtc2dfaWQYASABKAUSCwoDbXNnGAIgASgJEhAKCGlzX2Vycm9yGAMg",
            "ASgIEhAKCGlzX2FsZXJ0GAQgASgIEi8KCXBsYXllcl9pZBgFIAEoCzIcLmdv",
            "b2dsZS5wcm90b2J1Zi5TdHJpbmdWYWx1ZRIQCghsb2dfb25seRgGIAEoCCKo",
            "AQoRQ2hhcmFjdGVyU2VsZWN0ZWQSRAoIc2VsZWN0ZWQYASADKAsyMi5lbmRs",
            "ZXNzLnN0cmVhbS52MS5DaGFyYWN0ZXJTZWxlY3RlZC5TZWxlY3RlZEVudHJ5",
            "Gk0KDVNlbGVjdGVkRW50cnkSCwoDa2V5GAEgASgJEisKBXZhbHVlGAIgASgO",
            "MhwuZW5kbGVzcy5zdHJlYW0udjEuQ2xhc3NUeXBlOgI4ASJOCgRXYXZlEgsK",
            "A251bRgBIAEoBRIQCghoYXNfYm9zcxgCIAEoCBInCgVsZXZlbBgDIAEoDjIY",
            "LmVuZGxlc3Muc3RyZWFtLnYxLkxldmVsIsMECgxDdXJyZW50U3RhdGUSLAoI",
            "bW9uc3RlcnMYASADKAsyGi5lbmRsZXNzLnN0cmVhbS52MS5Nb25zdGVyEj0K",
            "B3BsYXllcnMYAiADKAsyLC5lbmRsZXNzLnN0cmVhbS52MS5DdXJyZW50U3Rh",
            "dGUuUGxheWVyc0VudHJ5EjQKDmN1cnJlbnRfcGxheWVyGAMgASgLMhwuZ29v",
            "Z2xlLnByb3RvYnVmLlN0cmluZ1ZhbHVlEisKB2Rpc3BsYXkYBCABKA4yGi5l",
            "bmRsZXNzLnN0cmVhbS52MS5EaXNwbGF5Ei0KDGN1cnJlbnRfd2F2ZRgFIAEo",
            "CzIXLmVuZGxlc3Muc3RyZWFtLnYxLldhdmUSSgoOdXBjb21pbmdfd2F2ZXMY",
            "BiADKAsyMi5lbmRsZXNzLnN0cmVhbS52MS5DdXJyZW50U3RhdGUuVXBjb21p",
            "bmdXYXZlc0VudHJ5EhYKDmF1ZGllbmNlX2NvdW50GAcgASgDEjYKCHNlbGVj",
            "dGVkGAggASgLMiQuZW5kbGVzcy5zdHJlYW0udjEuQ2hhcmFjdGVyU2VsZWN0",
            "ZWQaSQoMUGxheWVyc0VudHJ5EgsKA2tleRgBIAEoCRIoCgV2YWx1ZRgCIAEo",
            "CzIZLmVuZGxlc3Muc3RyZWFtLnYxLlBsYXllcjoCOAEaTQoSVXBjb21pbmdX",
            "YXZlc0VudHJ5EgsKA2tleRgBIAEoBRImCgV2YWx1ZRgCIAEoCzIXLmVuZGxl",
            "c3Muc3RyZWFtLnYxLldhdmU6AjgBIpoBCgRUaWNrEigKBHRpbWUYASABKAsy",
            "Gi5nb29nbGUucHJvdG9idWYuVGltZXN0YW1wEjcKCHByb2dyZXNzGAIgAygL",
            "MiUuZW5kbGVzcy5zdHJlYW0udjEuVGljay5Qcm9ncmVzc0VudHJ5Gi8KDVBy",
            "b2dyZXNzRW50cnkSCwoDa2V5GAEgASgJEg0KBXZhbHVlGAIgASgFOgI4ASJL",
            "CgpKb2luZWRHYW1lEgoKAmlkGAEgASgJEhMKC2FzX2F1ZGllbmNlGAIgASgI",
            "Eg4KBmlzX3ZpcBgDIAEoCBIMCgRuYW1lGAQgASgJIn8KBkFjdGlvbhIKCgJp",
            "ZBgBIAEoCRIQCghhY3Rvcl9pZBgCIAEoCRISCgp0YXJnZXRfaWRzGAMgAygJ",
            "EgsKA21zZxgEIAEoCRInCgVza2lsbBgGIAEoCzIYLmVuZGxlc3Muc3RyZWFt",
            "LnYxLlNraWxsEg0KBXZhbHVlGAcgASgFIo4CCg5TdG9yZUludmVudG9yeRJD",
            "CglpbnZlbnRvcnkYASADKAsyMC5lbmRsZXNzLnN0cmVhbS52MS5TdG9yZUlu",
            "dmVudG9yeS5JbnZlbnRvcnlFbnRyeRI9CgZwcmljZXMYAiADKAsyLS5lbmRs",
            "ZXNzLnN0cmVhbS52MS5TdG9yZUludmVudG9yeS5QcmljZXNFbnRyeRpJCg5J",
            "bnZlbnRvcnlFbnRyeRILCgNrZXkYASABKAkSJgoFdmFsdWUYAiABKAsyFy5l",
            "bmRsZXNzLnN0cmVhbS52MS5JdGVtOgI4ARotCgtQcmljZXNFbnRyeRILCgNr",
            "ZXkYASABKAkSDQoFdmFsdWUYAiABKAU6AjgBIrMCCgZPdXRwdXQSMAoFc3Rh",
            "dGUYASABKAsyHy5lbmRsZXNzLnN0cmVhbS52MS5DdXJyZW50U3RhdGVIABIv",
            "CgZqb2luZWQYAiABKAsyHS5lbmRsZXNzLnN0cmVhbS52MS5Kb2luZWRHYW1l",
            "SAASJwoEdGljaxgDIAEoCzIXLmVuZGxlc3Muc3RyZWFtLnYxLlRpY2tIABIu",
            "CgNtc2cYBCABKAsyHy5lbmRsZXNzLnN0cmVhbS52MS5FdmVudE1lc3NhZ2VI",
            "ABIrCgZhY3Rpb24YBSABKAsyGS5lbmRsZXNzLnN0cmVhbS52MS5BY3Rpb25I",
            "ABI4CghzZWxlY3RlZBgGIAEoCzIkLmVuZGxlc3Muc3RyZWFtLnYxLkNoYXJh",
            "Y3RlclNlbGVjdGVkSABCBgoEZGF0YSoyCgZUYXJnZXQSCAoEU2VsZhAAEgkK",
            "BU1lbGVlEAESCgoGUmFuZ2VkEAISBwoDQU9FEAMqKwoIUG9zaXRpb24SCAoE",
            "TGVmdBAAEgoKBk1pZGRsZRABEgkKBVJpZ2h0EAIqQgoPUHJvZ3Jlc3NCYXJU",
            "eXBlEhkKFUNvdW50ZG93bkdhbWVTdGFydGluZxAAEhQKEENvdW50ZG93blR1",
            "cm5FbmQQAUI1WjNnaXRodWIuY29tL3NlYW5oYWdlbi9lbmRsZXNzX3N0cmVh",
            "bS9iYWNrZW5kL2VuZGxlc3NiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Google.Protobuf.WellKnownTypes.WrappersReflection.Descriptor, global::Google.Protobuf.WellKnownTypes.TimestampReflection.Descriptor, global::Endless.Stream.V1.UtilReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Endless.Stream.V1.Target), typeof(global::Endless.Stream.V1.Position), typeof(global::Endless.Stream.V1.ProgressBarType), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Skill), global::Endless.Stream.V1.Skill.Parser, new[]{ "Id", "Name", "Level", "Target", "Cost", "Cooldown", "CooldownLeft", "Active", "Upgradable", "Description" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Item), global::Endless.Stream.V1.Item.Parser, new[]{ "Id", "Name", "Target", "Passive", "Bonus", "Count", "Active", "Description" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Creature), global::Endless.Stream.V1.Creature.Parser, new[]{ "Id", "Name", "MaxHp", "CurHp", "Position", "Statuses", "Strength", "Vitality", "CombatDamageBase", "VitalityRegen", "Intelligence", "Focus", "Willpower", "FocusRegen", "Agility", "Evasion", "Accuracy", "Initiative", "Gold", "Xp" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Player), global::Endless.Stream.V1.Player.Parser, new[]{ "Base", "Character", "IsAi", "Level", "Skills", "Inventory" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Monster), global::Endless.Stream.V1.Monster.Parser, new[]{ "Base", "Type", "IsFlying", "IsBoss" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.EventMessage), global::Endless.Stream.V1.EventMessage.Parser, new[]{ "MsgId", "Msg", "IsError", "IsAlert", "PlayerId", "LogOnly" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.CharacterSelected), global::Endless.Stream.V1.CharacterSelected.Parser, new[]{ "Selected" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Wave), global::Endless.Stream.V1.Wave.Parser, new[]{ "Num", "HasBoss", "Level" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.CurrentState), global::Endless.Stream.V1.CurrentState.Parser, new[]{ "Monsters", "Players", "CurrentPlayer", "Display", "CurrentWave", "UpcomingWaves", "AudienceCount", "Selected" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Tick), global::Endless.Stream.V1.Tick.Parser, new[]{ "Time", "Progress" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.JoinedGame), global::Endless.Stream.V1.JoinedGame.Parser, new[]{ "Id", "AsAudience", "IsVip", "Name" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Action), global::Endless.Stream.V1.Action.Parser, new[]{ "Id", "ActorId", "TargetIds", "Msg", "Skill", "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.StoreInventory), global::Endless.Stream.V1.StoreInventory.Parser, new[]{ "Inventory", "Prices" }, null, null, new pbr::GeneratedClrTypeInfo[] { null, null, }),
            new pbr::GeneratedClrTypeInfo(typeof(global::Endless.Stream.V1.Output), global::Endless.Stream.V1.Output.Parser, new[]{ "State", "Joined", "Tick", "Msg", "Action", "Selected" }, new[]{ "Data" }, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  public enum Target {
    /// <summary>
    /// Self means the skill/item only affects the actor
    /// </summary>
    [pbr::OriginalName("Self")] Self = 0,
    /// <summary>
    /// Melee means the actor must be in the same threat zone for the skill/item to affect them
    /// </summary>
    [pbr::OriginalName("Melee")] Melee = 1,
    /// <summary>
    /// Ranged means the actor can hit any other actor, regardless of positition
    /// </summary>
    [pbr::OriginalName("Ranged")] Ranged = 2,
    /// <summary>
    /// AOE means the skill/item affects all other actors in the chosen threat zone
    /// </summary>
    [pbr::OriginalName("AOE")] Aoe = 3,
  }

  /// <summary>
  /// Position describes where in the arena an actor is
  /// </summary>
  public enum Position {
    /// <summary>
    /// Left is the player side
    /// </summary>
    [pbr::OriginalName("Left")] Left = 0,
    /// <summary>
    /// Middle is the center of the arena
    /// </summary>
    [pbr::OriginalName("Middle")] Middle = 1,
    /// <summary>
    /// Right is the monster spawn side
    /// </summary>
    [pbr::OriginalName("Right")] Right = 2,
  }

  public enum ProgressBarType {
    [pbr::OriginalName("CountdownGameStarting")] CountdownGameStarting = 0,
    [pbr::OriginalName("CountdownTurnEnd")] CountdownTurnEnd = 1,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Skill represents a player skill that can be used during battle.
  /// </summary>
  public sealed partial class Skill : pb::IMessage<Skill> {
    private static readonly pb::MessageParser<Skill> _parser = new pb::MessageParser<Skill>(() => new Skill());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Skill> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Skill() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Skill(Skill other) : this() {
      id_ = other.id_;
      name_ = other.name_;
      level_ = other.level_;
      target_ = other.target_;
      cost_ = other.cost_;
      cooldown_ = other.cooldown_;
      cooldownLeft_ = other.cooldownLeft_;
      active_ = other.active_;
      upgradable_ = other.upgradable_;
      description_ = other.description_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Skill Clone() {
      return new Skill(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    /// Id is the UUID of the skill
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// Name is the human-readable name of the skill
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "level" field.</summary>
    public const int LevelFieldNumber = 3;
    private int level_;
    /// <summary>
    /// Level is the current level of the skill, starts at 0 for all
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Level {
      get { return level_; }
      set {
        level_ = value;
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 4;
    private global::Endless.Stream.V1.Target target_ = 0;
    /// <summary>
    /// Target is for who/what the skill can target
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Target Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    /// <summary>Field number for the "cost" field.</summary>
    public const int CostFieldNumber = 5;
    private int cost_;
    /// <summary>
    /// Cost is how much focus is required to activate the skill
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Cost {
      get { return cost_; }
      set {
        cost_ = value;
      }
    }

    /// <summary>Field number for the "cooldown" field.</summary>
    public const int CooldownFieldNumber = 6;
    private int cooldown_;
    /// <summary>
    /// Cooldown is how many turns it takes for the skill to become usable again
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Cooldown {
      get { return cooldown_; }
      set {
        cooldown_ = value;
      }
    }

    /// <summary>Field number for the "cooldown_left" field.</summary>
    public const int CooldownLeftFieldNumber = 7;
    private int cooldownLeft_;
    /// <summary>
    /// CooldownLeft is how many turns are left until the skill is usable again
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CooldownLeft {
      get { return cooldownLeft_; }
      set {
        cooldownLeft_ = value;
      }
    }

    /// <summary>Field number for the "active" field.</summary>
    public const int ActiveFieldNumber = 8;
    private bool active_;
    /// <summary>
    /// Active is true when the skill is usable. If the skill isn't unlocked, or a status
    /// prevents the usage of the skill, this will be false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Active {
      get { return active_; }
      set {
        active_ = value;
      }
    }

    /// <summary>Field number for the "upgradable" field.</summary>
    public const int UpgradableFieldNumber = 9;
    private bool upgradable_;
    /// <summary>
    /// Upgradable is true while the skill is upgradable. Once a skill has reached max level
    /// this becomes false.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Upgradable {
      get { return upgradable_; }
      set {
        upgradable_ = value;
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 50;
    private string description_ = "";
    /// <summary>
    /// Description is a human readable name for the skill.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Skill);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Skill other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Name != other.Name) return false;
      if (Level != other.Level) return false;
      if (Target != other.Target) return false;
      if (Cost != other.Cost) return false;
      if (Cooldown != other.Cooldown) return false;
      if (CooldownLeft != other.CooldownLeft) return false;
      if (Active != other.Active) return false;
      if (Upgradable != other.Upgradable) return false;
      if (Description != other.Description) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Level != 0) hash ^= Level.GetHashCode();
      if (Target != 0) hash ^= Target.GetHashCode();
      if (Cost != 0) hash ^= Cost.GetHashCode();
      if (Cooldown != 0) hash ^= Cooldown.GetHashCode();
      if (CooldownLeft != 0) hash ^= CooldownLeft.GetHashCode();
      if (Active != false) hash ^= Active.GetHashCode();
      if (Upgradable != false) hash ^= Upgradable.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Level != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(Level);
      }
      if (Target != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Target);
      }
      if (Cost != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(Cost);
      }
      if (Cooldown != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(Cooldown);
      }
      if (CooldownLeft != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(CooldownLeft);
      }
      if (Active != false) {
        output.WriteRawTag(64);
        output.WriteBool(Active);
      }
      if (Upgradable != false) {
        output.WriteRawTag(72);
        output.WriteBool(Upgradable);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(146, 3);
        output.WriteString(Description);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Level != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Level);
      }
      if (Target != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Target);
      }
      if (Cost != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Cost);
      }
      if (Cooldown != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Cooldown);
      }
      if (CooldownLeft != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CooldownLeft);
      }
      if (Active != false) {
        size += 1 + 1;
      }
      if (Upgradable != false) {
        size += 1 + 1;
      }
      if (Description.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Skill other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Level != 0) {
        Level = other.Level;
      }
      if (other.Target != 0) {
        Target = other.Target;
      }
      if (other.Cost != 0) {
        Cost = other.Cost;
      }
      if (other.Cooldown != 0) {
        Cooldown = other.Cooldown;
      }
      if (other.CooldownLeft != 0) {
        CooldownLeft = other.CooldownLeft;
      }
      if (other.Active != false) {
        Active = other.Active;
      }
      if (other.Upgradable != false) {
        Upgradable = other.Upgradable;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 24: {
            Level = input.ReadInt32();
            break;
          }
          case 32: {
            Target = (global::Endless.Stream.V1.Target) input.ReadEnum();
            break;
          }
          case 40: {
            Cost = input.ReadInt32();
            break;
          }
          case 48: {
            Cooldown = input.ReadInt32();
            break;
          }
          case 56: {
            CooldownLeft = input.ReadInt32();
            break;
          }
          case 64: {
            Active = input.ReadBool();
            break;
          }
          case 72: {
            Upgradable = input.ReadBool();
            break;
          }
          case 402: {
            Description = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Item represents something the player can carry and use.
  /// </summary>
  public sealed partial class Item : pb::IMessage<Item> {
    private static readonly pb::MessageParser<Item> _parser = new pb::MessageParser<Item>(() => new Item());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Item> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Item() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Item(Item other) : this() {
      id_ = other.id_;
      name_ = other.name_;
      target_ = other.target_;
      passive_ = other.passive_;
      bonus_ = other.bonus_.Clone();
      count_ = other.count_;
      active_ = other.active_;
      description_ = other.description_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Item Clone() {
      return new Item(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    /// Id is the UUID that represents the item
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// Name is the human-readable name of the item
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "target" field.</summary>
    public const int TargetFieldNumber = 3;
    private global::Endless.Stream.V1.Target target_ = 0;
    /// <summary>
    /// Target is so the UI can show how many targets the item can affect
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Target Target {
      get { return target_; }
      set {
        target_ = value;
      }
    }

    /// <summary>Field number for the "passive" field.</summary>
    public const int PassiveFieldNumber = 4;
    private bool passive_;
    /// <summary>
    /// Passive is if the item is passive/equipable
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Passive {
      get { return passive_; }
      set {
        passive_ = value;
      }
    }

    /// <summary>Field number for the "bonus" field.</summary>
    public const int BonusFieldNumber = 6;
    private static readonly pbc::MapField<string, int>.Codec _map_bonus_codec
        = new pbc::MapField<string, int>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForInt32(16), 50);
    private readonly pbc::MapField<string, int> bonus_ = new pbc::MapField<string, int>();
    /// <summary>
    /// Bonus is a map of attribute name -> bonus that shows how the item affects
    /// the player character ( ongoing for passive items, or immediate bonus otherwise)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, int> Bonus {
      get { return bonus_; }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 7;
    private int count_;
    /// <summary>
    /// Count is how many copies of this item the player has
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "active" field.</summary>
    public const int ActiveFieldNumber = 8;
    private bool active_;
    /// <summary>
    /// Active is if the item is currently usable. Some items can be used at any time
    /// (such as health potions), some are only usable on that players turn
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Active {
      get { return active_; }
      set {
        active_ = value;
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 50;
    private string description_ = "";
    /// <summary>
    /// Description is the human readable description of what the item is
    /// and what it does
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Item);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Item other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Name != other.Name) return false;
      if (Target != other.Target) return false;
      if (Passive != other.Passive) return false;
      if (!Bonus.Equals(other.Bonus)) return false;
      if (Count != other.Count) return false;
      if (Active != other.Active) return false;
      if (Description != other.Description) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Target != 0) hash ^= Target.GetHashCode();
      if (Passive != false) hash ^= Passive.GetHashCode();
      hash ^= Bonus.GetHashCode();
      if (Count != 0) hash ^= Count.GetHashCode();
      if (Active != false) hash ^= Active.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (Target != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Target);
      }
      if (Passive != false) {
        output.WriteRawTag(32);
        output.WriteBool(Passive);
      }
      bonus_.WriteTo(output, _map_bonus_codec);
      if (Count != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(Count);
      }
      if (Active != false) {
        output.WriteRawTag(64);
        output.WriteBool(Active);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(146, 3);
        output.WriteString(Description);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Target != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Target);
      }
      if (Passive != false) {
        size += 1 + 1;
      }
      size += bonus_.CalculateSize(_map_bonus_codec);
      if (Count != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Count);
      }
      if (Active != false) {
        size += 1 + 1;
      }
      if (Description.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Item other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Target != 0) {
        Target = other.Target;
      }
      if (other.Passive != false) {
        Passive = other.Passive;
      }
      bonus_.Add(other.bonus_);
      if (other.Count != 0) {
        Count = other.Count;
      }
      if (other.Active != false) {
        Active = other.Active;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 24: {
            Target = (global::Endless.Stream.V1.Target) input.ReadEnum();
            break;
          }
          case 32: {
            Passive = input.ReadBool();
            break;
          }
          case 50: {
            bonus_.AddEntriesFrom(input, _map_bonus_codec);
            break;
          }
          case 56: {
            Count = input.ReadInt32();
            break;
          }
          case 64: {
            Active = input.ReadBool();
            break;
          }
          case 402: {
            Description = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Creature is the base stats shared by characters and monsters
  /// </summary>
  public sealed partial class Creature : pb::IMessage<Creature> {
    private static readonly pb::MessageParser<Creature> _parser = new pb::MessageParser<Creature>(() => new Creature());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Creature> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Creature() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Creature(Creature other) : this() {
      id_ = other.id_;
      name_ = other.name_;
      maxHp_ = other.maxHp_;
      curHp_ = other.curHp_;
      position_ = other.position_;
      statuses_ = other.statuses_.Clone();
      strength_ = other.strength_;
      vitality_ = other.vitality_;
      combatDamageBase_ = other.combatDamageBase_;
      vitalityRegen_ = other.vitalityRegen_;
      intelligence_ = other.intelligence_;
      focus_ = other.focus_;
      willpower_ = other.willpower_;
      focusRegen_ = other.focusRegen_;
      agility_ = other.agility_;
      evasion_ = other.evasion_;
      accuracy_ = other.accuracy_;
      initiative_ = other.initiative_;
      gold_ = other.gold_;
      xp_ = other.xp_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Creature Clone() {
      return new Creature(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    /// Id is the UUID for the creature
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// Name is the human readable name
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "max_hp" field.</summary>
    public const int MaxHpFieldNumber = 3;
    private int maxHp_;
    /// <summary>
    /// MaxHp is the maximum amount of HP the creature can have
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxHp {
      get { return maxHp_; }
      set {
        maxHp_ = value;
      }
    }

    /// <summary>Field number for the "cur_hp" field.</summary>
    public const int CurHpFieldNumber = 4;
    private int curHp_;
    /// <summary>
    /// CurHp is the current HP value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CurHp {
      get { return curHp_; }
      set {
        curHp_ = value;
      }
    }

    /// <summary>Field number for the "position" field.</summary>
    public const int PositionFieldNumber = 5;
    private global::Endless.Stream.V1.Position position_ = 0;
    /// <summary>
    /// Position deetermines what threat zone the creature is currently standing in
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Position Position {
      get { return position_; }
      set {
        position_ = value;
      }
    }

    /// <summary>Field number for the "statuses" field.</summary>
    public const int StatusesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::Endless.Stream.V1.StatusEffect> _repeated_statuses_codec
        = pb::FieldCodec.ForEnum(50, x => (int) x, x => (global::Endless.Stream.V1.StatusEffect) x);
    private readonly pbc::RepeatedField<global::Endless.Stream.V1.StatusEffect> statuses_ = new pbc::RepeatedField<global::Endless.Stream.V1.StatusEffect>();
    /// <summary>
    /// Statuses is a list of effects that currently affect this creature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Endless.Stream.V1.StatusEffect> Statuses {
      get { return statuses_; }
    }

    /// <summary>Field number for the "strength" field.</summary>
    public const int StrengthFieldNumber = 20;
    private int strength_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Strength {
      get { return strength_; }
      set {
        strength_ = value;
      }
    }

    /// <summary>Field number for the "vitality" field.</summary>
    public const int VitalityFieldNumber = 21;
    private int vitality_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Vitality {
      get { return vitality_; }
      set {
        vitality_ = value;
      }
    }

    /// <summary>Field number for the "combat_damage_base" field.</summary>
    public const int CombatDamageBaseFieldNumber = 22;
    private int combatDamageBase_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CombatDamageBase {
      get { return combatDamageBase_; }
      set {
        combatDamageBase_ = value;
      }
    }

    /// <summary>Field number for the "vitality_regen" field.</summary>
    public const int VitalityRegenFieldNumber = 23;
    private int vitalityRegen_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int VitalityRegen {
      get { return vitalityRegen_; }
      set {
        vitalityRegen_ = value;
      }
    }

    /// <summary>Field number for the "intelligence" field.</summary>
    public const int IntelligenceFieldNumber = 30;
    private int intelligence_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Intelligence {
      get { return intelligence_; }
      set {
        intelligence_ = value;
      }
    }

    /// <summary>Field number for the "focus" field.</summary>
    public const int FocusFieldNumber = 31;
    private int focus_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Focus {
      get { return focus_; }
      set {
        focus_ = value;
      }
    }

    /// <summary>Field number for the "willpower" field.</summary>
    public const int WillpowerFieldNumber = 32;
    private int willpower_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Willpower {
      get { return willpower_; }
      set {
        willpower_ = value;
      }
    }

    /// <summary>Field number for the "focus_regen" field.</summary>
    public const int FocusRegenFieldNumber = 33;
    private int focusRegen_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int FocusRegen {
      get { return focusRegen_; }
      set {
        focusRegen_ = value;
      }
    }

    /// <summary>Field number for the "agility" field.</summary>
    public const int AgilityFieldNumber = 40;
    private int agility_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Agility {
      get { return agility_; }
      set {
        agility_ = value;
      }
    }

    /// <summary>Field number for the "evasion" field.</summary>
    public const int EvasionFieldNumber = 41;
    private int evasion_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Evasion {
      get { return evasion_; }
      set {
        evasion_ = value;
      }
    }

    /// <summary>Field number for the "accuracy" field.</summary>
    public const int AccuracyFieldNumber = 42;
    private int accuracy_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Accuracy {
      get { return accuracy_; }
      set {
        accuracy_ = value;
      }
    }

    /// <summary>Field number for the "initiative" field.</summary>
    public const int InitiativeFieldNumber = 43;
    private int initiative_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Initiative {
      get { return initiative_; }
      set {
        initiative_ = value;
      }
    }

    /// <summary>Field number for the "gold" field.</summary>
    public const int GoldFieldNumber = 50;
    private long gold_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Gold {
      get { return gold_; }
      set {
        gold_ = value;
      }
    }

    /// <summary>Field number for the "xp" field.</summary>
    public const int XpFieldNumber = 51;
    private long xp_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Xp {
      get { return xp_; }
      set {
        xp_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Creature);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Creature other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Name != other.Name) return false;
      if (MaxHp != other.MaxHp) return false;
      if (CurHp != other.CurHp) return false;
      if (Position != other.Position) return false;
      if(!statuses_.Equals(other.statuses_)) return false;
      if (Strength != other.Strength) return false;
      if (Vitality != other.Vitality) return false;
      if (CombatDamageBase != other.CombatDamageBase) return false;
      if (VitalityRegen != other.VitalityRegen) return false;
      if (Intelligence != other.Intelligence) return false;
      if (Focus != other.Focus) return false;
      if (Willpower != other.Willpower) return false;
      if (FocusRegen != other.FocusRegen) return false;
      if (Agility != other.Agility) return false;
      if (Evasion != other.Evasion) return false;
      if (Accuracy != other.Accuracy) return false;
      if (Initiative != other.Initiative) return false;
      if (Gold != other.Gold) return false;
      if (Xp != other.Xp) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (MaxHp != 0) hash ^= MaxHp.GetHashCode();
      if (CurHp != 0) hash ^= CurHp.GetHashCode();
      if (Position != 0) hash ^= Position.GetHashCode();
      hash ^= statuses_.GetHashCode();
      if (Strength != 0) hash ^= Strength.GetHashCode();
      if (Vitality != 0) hash ^= Vitality.GetHashCode();
      if (CombatDamageBase != 0) hash ^= CombatDamageBase.GetHashCode();
      if (VitalityRegen != 0) hash ^= VitalityRegen.GetHashCode();
      if (Intelligence != 0) hash ^= Intelligence.GetHashCode();
      if (Focus != 0) hash ^= Focus.GetHashCode();
      if (Willpower != 0) hash ^= Willpower.GetHashCode();
      if (FocusRegen != 0) hash ^= FocusRegen.GetHashCode();
      if (Agility != 0) hash ^= Agility.GetHashCode();
      if (Evasion != 0) hash ^= Evasion.GetHashCode();
      if (Accuracy != 0) hash ^= Accuracy.GetHashCode();
      if (Initiative != 0) hash ^= Initiative.GetHashCode();
      if (Gold != 0L) hash ^= Gold.GetHashCode();
      if (Xp != 0L) hash ^= Xp.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      if (MaxHp != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MaxHp);
      }
      if (CurHp != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(CurHp);
      }
      if (Position != 0) {
        output.WriteRawTag(40);
        output.WriteEnum((int) Position);
      }
      statuses_.WriteTo(output, _repeated_statuses_codec);
      if (Strength != 0) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(Strength);
      }
      if (Vitality != 0) {
        output.WriteRawTag(168, 1);
        output.WriteInt32(Vitality);
      }
      if (CombatDamageBase != 0) {
        output.WriteRawTag(176, 1);
        output.WriteInt32(CombatDamageBase);
      }
      if (VitalityRegen != 0) {
        output.WriteRawTag(184, 1);
        output.WriteInt32(VitalityRegen);
      }
      if (Intelligence != 0) {
        output.WriteRawTag(240, 1);
        output.WriteInt32(Intelligence);
      }
      if (Focus != 0) {
        output.WriteRawTag(248, 1);
        output.WriteInt32(Focus);
      }
      if (Willpower != 0) {
        output.WriteRawTag(128, 2);
        output.WriteInt32(Willpower);
      }
      if (FocusRegen != 0) {
        output.WriteRawTag(136, 2);
        output.WriteInt32(FocusRegen);
      }
      if (Agility != 0) {
        output.WriteRawTag(192, 2);
        output.WriteInt32(Agility);
      }
      if (Evasion != 0) {
        output.WriteRawTag(200, 2);
        output.WriteInt32(Evasion);
      }
      if (Accuracy != 0) {
        output.WriteRawTag(208, 2);
        output.WriteInt32(Accuracy);
      }
      if (Initiative != 0) {
        output.WriteRawTag(216, 2);
        output.WriteInt32(Initiative);
      }
      if (Gold != 0L) {
        output.WriteRawTag(144, 3);
        output.WriteInt64(Gold);
      }
      if (Xp != 0L) {
        output.WriteRawTag(152, 3);
        output.WriteInt64(Xp);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (MaxHp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxHp);
      }
      if (CurHp != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CurHp);
      }
      if (Position != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Position);
      }
      size += statuses_.CalculateSize(_repeated_statuses_codec);
      if (Strength != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Strength);
      }
      if (Vitality != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Vitality);
      }
      if (CombatDamageBase != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(CombatDamageBase);
      }
      if (VitalityRegen != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(VitalityRegen);
      }
      if (Intelligence != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Intelligence);
      }
      if (Focus != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Focus);
      }
      if (Willpower != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Willpower);
      }
      if (FocusRegen != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(FocusRegen);
      }
      if (Agility != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Agility);
      }
      if (Evasion != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Evasion);
      }
      if (Accuracy != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Accuracy);
      }
      if (Initiative != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(Initiative);
      }
      if (Gold != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(Gold);
      }
      if (Xp != 0L) {
        size += 2 + pb::CodedOutputStream.ComputeInt64Size(Xp);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Creature other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.MaxHp != 0) {
        MaxHp = other.MaxHp;
      }
      if (other.CurHp != 0) {
        CurHp = other.CurHp;
      }
      if (other.Position != 0) {
        Position = other.Position;
      }
      statuses_.Add(other.statuses_);
      if (other.Strength != 0) {
        Strength = other.Strength;
      }
      if (other.Vitality != 0) {
        Vitality = other.Vitality;
      }
      if (other.CombatDamageBase != 0) {
        CombatDamageBase = other.CombatDamageBase;
      }
      if (other.VitalityRegen != 0) {
        VitalityRegen = other.VitalityRegen;
      }
      if (other.Intelligence != 0) {
        Intelligence = other.Intelligence;
      }
      if (other.Focus != 0) {
        Focus = other.Focus;
      }
      if (other.Willpower != 0) {
        Willpower = other.Willpower;
      }
      if (other.FocusRegen != 0) {
        FocusRegen = other.FocusRegen;
      }
      if (other.Agility != 0) {
        Agility = other.Agility;
      }
      if (other.Evasion != 0) {
        Evasion = other.Evasion;
      }
      if (other.Accuracy != 0) {
        Accuracy = other.Accuracy;
      }
      if (other.Initiative != 0) {
        Initiative = other.Initiative;
      }
      if (other.Gold != 0L) {
        Gold = other.Gold;
      }
      if (other.Xp != 0L) {
        Xp = other.Xp;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 24: {
            MaxHp = input.ReadInt32();
            break;
          }
          case 32: {
            CurHp = input.ReadInt32();
            break;
          }
          case 40: {
            Position = (global::Endless.Stream.V1.Position) input.ReadEnum();
            break;
          }
          case 50:
          case 48: {
            statuses_.AddEntriesFrom(input, _repeated_statuses_codec);
            break;
          }
          case 160: {
            Strength = input.ReadInt32();
            break;
          }
          case 168: {
            Vitality = input.ReadInt32();
            break;
          }
          case 176: {
            CombatDamageBase = input.ReadInt32();
            break;
          }
          case 184: {
            VitalityRegen = input.ReadInt32();
            break;
          }
          case 240: {
            Intelligence = input.ReadInt32();
            break;
          }
          case 248: {
            Focus = input.ReadInt32();
            break;
          }
          case 256: {
            Willpower = input.ReadInt32();
            break;
          }
          case 264: {
            FocusRegen = input.ReadInt32();
            break;
          }
          case 320: {
            Agility = input.ReadInt32();
            break;
          }
          case 328: {
            Evasion = input.ReadInt32();
            break;
          }
          case 336: {
            Accuracy = input.ReadInt32();
            break;
          }
          case 344: {
            Initiative = input.ReadInt32();
            break;
          }
          case 400: {
            Gold = input.ReadInt64();
            break;
          }
          case 408: {
            Xp = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Player represents a user or AI controlled character
  /// </summary>
  public sealed partial class Player : pb::IMessage<Player> {
    private static readonly pb::MessageParser<Player> _parser = new pb::MessageParser<Player>(() => new Player());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Player> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Player() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Player(Player other) : this() {
      base_ = other.base_ != null ? other.base_.Clone() : null;
      character_ = other.character_ != null ? other.character_.Clone() : null;
      isAi_ = other.isAi_;
      level_ = other.level_;
      skills_ = other.skills_.Clone();
      inventory_ = other.inventory_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Player Clone() {
      return new Player(this);
    }

    /// <summary>Field number for the "base" field.</summary>
    public const int BaseFieldNumber = 1;
    private global::Endless.Stream.V1.Creature base_;
    /// <summary>
    /// Base is the basic stats of the player
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Creature Base {
      get { return base_; }
      set {
        base_ = value;
      }
    }

    /// <summary>Field number for the "character" field.</summary>
    public const int CharacterFieldNumber = 2;
    private global::Endless.Stream.V1.Class character_;
    /// <summary>
    /// Character is what class the player is playing as (or if they're the status screen or an audience member)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Class Character {
      get { return character_; }
      set {
        character_ = value;
      }
    }

    /// <summary>Field number for the "is_ai" field.</summary>
    public const int IsAiFieldNumber = 3;
    private bool isAi_;
    /// <summary>
    /// IsAI is true if this player is currently controlled by an AI
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAi {
      get { return isAi_; }
      set {
        isAi_ = value;
      }
    }

    /// <summary>Field number for the "level" field.</summary>
    public const int LevelFieldNumber = 4;
    private int level_;
    /// <summary>
    /// Level is their current character level, starts at 1
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Level {
      get { return level_; }
      set {
        level_ = value;
      }
    }

    /// <summary>Field number for the "skills" field.</summary>
    public const int SkillsFieldNumber = 5;
    private static readonly pbc::MapField<string, global::Endless.Stream.V1.Skill>.Codec _map_skills_codec
        = new pbc::MapField<string, global::Endless.Stream.V1.Skill>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Endless.Stream.V1.Skill.Parser), 42);
    private readonly pbc::MapField<string, global::Endless.Stream.V1.Skill> skills_ = new pbc::MapField<string, global::Endless.Stream.V1.Skill>();
    /// <summary>
    /// Skills is a map of ID to skill
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Endless.Stream.V1.Skill> Skills {
      get { return skills_; }
    }

    /// <summary>Field number for the "inventory" field.</summary>
    public const int InventoryFieldNumber = 6;
    private static readonly pbc::MapField<string, global::Endless.Stream.V1.Item>.Codec _map_inventory_codec
        = new pbc::MapField<string, global::Endless.Stream.V1.Item>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Endless.Stream.V1.Item.Parser), 50);
    private readonly pbc::MapField<string, global::Endless.Stream.V1.Item> inventory_ = new pbc::MapField<string, global::Endless.Stream.V1.Item>();
    /// <summary>
    /// Inventory is a map of ID to items currently held by this player
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Endless.Stream.V1.Item> Inventory {
      get { return inventory_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Player);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Player other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Base, other.Base)) return false;
      if (!object.Equals(Character, other.Character)) return false;
      if (IsAi != other.IsAi) return false;
      if (Level != other.Level) return false;
      if (!Skills.Equals(other.Skills)) return false;
      if (!Inventory.Equals(other.Inventory)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (base_ != null) hash ^= Base.GetHashCode();
      if (character_ != null) hash ^= Character.GetHashCode();
      if (IsAi != false) hash ^= IsAi.GetHashCode();
      if (Level != 0) hash ^= Level.GetHashCode();
      hash ^= Skills.GetHashCode();
      hash ^= Inventory.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (base_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Base);
      }
      if (character_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Character);
      }
      if (IsAi != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsAi);
      }
      if (Level != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(Level);
      }
      skills_.WriteTo(output, _map_skills_codec);
      inventory_.WriteTo(output, _map_inventory_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (base_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Base);
      }
      if (character_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Character);
      }
      if (IsAi != false) {
        size += 1 + 1;
      }
      if (Level != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Level);
      }
      size += skills_.CalculateSize(_map_skills_codec);
      size += inventory_.CalculateSize(_map_inventory_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Player other) {
      if (other == null) {
        return;
      }
      if (other.base_ != null) {
        if (base_ == null) {
          Base = new global::Endless.Stream.V1.Creature();
        }
        Base.MergeFrom(other.Base);
      }
      if (other.character_ != null) {
        if (character_ == null) {
          Character = new global::Endless.Stream.V1.Class();
        }
        Character.MergeFrom(other.Character);
      }
      if (other.IsAi != false) {
        IsAi = other.IsAi;
      }
      if (other.Level != 0) {
        Level = other.Level;
      }
      skills_.Add(other.skills_);
      inventory_.Add(other.inventory_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (base_ == null) {
              Base = new global::Endless.Stream.V1.Creature();
            }
            input.ReadMessage(Base);
            break;
          }
          case 18: {
            if (character_ == null) {
              Character = new global::Endless.Stream.V1.Class();
            }
            input.ReadMessage(Character);
            break;
          }
          case 24: {
            IsAi = input.ReadBool();
            break;
          }
          case 32: {
            Level = input.ReadInt32();
            break;
          }
          case 42: {
            skills_.AddEntriesFrom(input, _map_skills_codec);
            break;
          }
          case 50: {
            inventory_.AddEntriesFrom(input, _map_inventory_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Monster represents an enemy the characters are fighting
  /// </summary>
  public sealed partial class Monster : pb::IMessage<Monster> {
    private static readonly pb::MessageParser<Monster> _parser = new pb::MessageParser<Monster>(() => new Monster());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Monster> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Monster() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Monster(Monster other) : this() {
      base_ = other.base_ != null ? other.base_.Clone() : null;
      type_ = other.type_;
      isFlying_ = other.isFlying_;
      isBoss_ = other.isBoss_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Monster Clone() {
      return new Monster(this);
    }

    /// <summary>Field number for the "base" field.</summary>
    public const int BaseFieldNumber = 1;
    private global::Endless.Stream.V1.Creature base_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Creature Base {
      get { return base_; }
      set {
        base_ = value;
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 3;
    private global::Endless.Stream.V1.Type type_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Type Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "is_flying" field.</summary>
    public const int IsFlyingFieldNumber = 4;
    private bool isFlying_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFlying {
      get { return isFlying_; }
      set {
        isFlying_ = value;
      }
    }

    /// <summary>Field number for the "is_boss" field.</summary>
    public const int IsBossFieldNumber = 5;
    private bool isBoss_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsBoss {
      get { return isBoss_; }
      set {
        isBoss_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Monster);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Monster other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Base, other.Base)) return false;
      if (Type != other.Type) return false;
      if (IsFlying != other.IsFlying) return false;
      if (IsBoss != other.IsBoss) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (base_ != null) hash ^= Base.GetHashCode();
      if (Type != 0) hash ^= Type.GetHashCode();
      if (IsFlying != false) hash ^= IsFlying.GetHashCode();
      if (IsBoss != false) hash ^= IsBoss.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (base_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Base);
      }
      if (Type != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Type);
      }
      if (IsFlying != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsFlying);
      }
      if (IsBoss != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsBoss);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (base_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Base);
      }
      if (Type != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Type);
      }
      if (IsFlying != false) {
        size += 1 + 1;
      }
      if (IsBoss != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Monster other) {
      if (other == null) {
        return;
      }
      if (other.base_ != null) {
        if (base_ == null) {
          Base = new global::Endless.Stream.V1.Creature();
        }
        Base.MergeFrom(other.Base);
      }
      if (other.Type != 0) {
        Type = other.Type;
      }
      if (other.IsFlying != false) {
        IsFlying = other.IsFlying;
      }
      if (other.IsBoss != false) {
        IsBoss = other.IsBoss;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (base_ == null) {
              Base = new global::Endless.Stream.V1.Creature();
            }
            input.ReadMessage(Base);
            break;
          }
          case 24: {
            Type = (global::Endless.Stream.V1.Type) input.ReadEnum();
            break;
          }
          case 32: {
            IsFlying = input.ReadBool();
            break;
          }
          case 40: {
            IsBoss = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// EventMessage is used when the game needs to display a message in the UI
  /// </summary>
  public sealed partial class EventMessage : pb::IMessage<EventMessage> {
    private static readonly pb::MessageParser<EventMessage> _parser = new pb::MessageParser<EventMessage>(() => new EventMessage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EventMessage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EventMessage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EventMessage(EventMessage other) : this() {
      msgId_ = other.msgId_;
      msg_ = other.msg_;
      isError_ = other.isError_;
      isAlert_ = other.isAlert_;
      PlayerId = other.PlayerId;
      logOnly_ = other.logOnly_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EventMessage Clone() {
      return new EventMessage(this);
    }

    /// <summary>Field number for the "msg_id" field.</summary>
    public const int MsgIdFieldNumber = 1;
    private int msgId_;
    /// <summary>
    /// MsgId is the id of the message
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MsgId {
      get { return msgId_; }
      set {
        msgId_ = value;
      }
    }

    /// <summary>Field number for the "msg" field.</summary>
    public const int MsgFieldNumber = 2;
    private string msg_ = "";
    /// <summary>
    /// Msg contains the message content
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Msg {
      get { return msg_; }
      set {
        msg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "is_error" field.</summary>
    public const int IsErrorFieldNumber = 3;
    private bool isError_;
    /// <summary>
    /// IsError is true if the message is about an error that has occured
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsError {
      get { return isError_; }
      set {
        isError_ = value;
      }
    }

    /// <summary>Field number for the "is_alert" field.</summary>
    public const int IsAlertFieldNumber = 4;
    private bool isAlert_;
    /// <summary>
    /// IsAlert is true if the message is an alert, and only has an "Ok" button.
    /// False means it's a confirmation, which has an "Yes" &amp; "No" button
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsAlert {
      get { return isAlert_; }
      set {
        isAlert_ = value;
      }
    }

    /// <summary>Field number for the "player_id" field.</summary>
    public const int PlayerIdFieldNumber = 5;
    private static readonly pb::FieldCodec<string> _single_playerId_codec = pb::FieldCodec.ForClassWrapper<string>(42);
    private string playerId_;
    /// <summary>
    /// PlayerId is set only if the message is for a specific player.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PlayerId {
      get { return playerId_; }
      set {
        playerId_ = value;
      }
    }


    /// <summary>Field number for the "log_only" field.</summary>
    public const int LogOnlyFieldNumber = 6;
    private bool logOnly_;
    /// <summary>
    /// LogOnly is a boolean that if true, messages go into the player log without
    /// getting any kind of notification
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool LogOnly {
      get { return logOnly_; }
      set {
        logOnly_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EventMessage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EventMessage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MsgId != other.MsgId) return false;
      if (Msg != other.Msg) return false;
      if (IsError != other.IsError) return false;
      if (IsAlert != other.IsAlert) return false;
      if (PlayerId != other.PlayerId) return false;
      if (LogOnly != other.LogOnly) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MsgId != 0) hash ^= MsgId.GetHashCode();
      if (Msg.Length != 0) hash ^= Msg.GetHashCode();
      if (IsError != false) hash ^= IsError.GetHashCode();
      if (IsAlert != false) hash ^= IsAlert.GetHashCode();
      if (playerId_ != null) hash ^= PlayerId.GetHashCode();
      if (LogOnly != false) hash ^= LogOnly.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MsgId != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MsgId);
      }
      if (Msg.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Msg);
      }
      if (IsError != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsError);
      }
      if (IsAlert != false) {
        output.WriteRawTag(32);
        output.WriteBool(IsAlert);
      }
      if (playerId_ != null) {
        _single_playerId_codec.WriteTagAndValue(output, PlayerId);
      }
      if (LogOnly != false) {
        output.WriteRawTag(48);
        output.WriteBool(LogOnly);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MsgId != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MsgId);
      }
      if (Msg.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Msg);
      }
      if (IsError != false) {
        size += 1 + 1;
      }
      if (IsAlert != false) {
        size += 1 + 1;
      }
      if (playerId_ != null) {
        size += _single_playerId_codec.CalculateSizeWithTag(PlayerId);
      }
      if (LogOnly != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EventMessage other) {
      if (other == null) {
        return;
      }
      if (other.MsgId != 0) {
        MsgId = other.MsgId;
      }
      if (other.Msg.Length != 0) {
        Msg = other.Msg;
      }
      if (other.IsError != false) {
        IsError = other.IsError;
      }
      if (other.IsAlert != false) {
        IsAlert = other.IsAlert;
      }
      if (other.playerId_ != null) {
        if (playerId_ == null || other.PlayerId != "") {
          PlayerId = other.PlayerId;
        }
      }
      if (other.LogOnly != false) {
        LogOnly = other.LogOnly;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MsgId = input.ReadInt32();
            break;
          }
          case 18: {
            Msg = input.ReadString();
            break;
          }
          case 24: {
            IsError = input.ReadBool();
            break;
          }
          case 32: {
            IsAlert = input.ReadBool();
            break;
          }
          case 42: {
            string value = _single_playerId_codec.Read(input);
            if (playerId_ == null || value != "") {
              PlayerId = value;
            }
            break;
          }
          case 48: {
            LogOnly = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// CharacterSelected is sent by the game when someone selects a character
  /// on the character selection screen. This is used to disable that character in the UI
  /// so nobody else can select it.
  /// </summary>
  public sealed partial class CharacterSelected : pb::IMessage<CharacterSelected> {
    private static readonly pb::MessageParser<CharacterSelected> _parser = new pb::MessageParser<CharacterSelected>(() => new CharacterSelected());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CharacterSelected> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CharacterSelected() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CharacterSelected(CharacterSelected other) : this() {
      selected_ = other.selected_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CharacterSelected Clone() {
      return new CharacterSelected(this);
    }

    /// <summary>Field number for the "selected" field.</summary>
    public const int SelectedFieldNumber = 1;
    private static readonly pbc::MapField<string, global::Endless.Stream.V1.ClassType>.Codec _map_selected_codec
        = new pbc::MapField<string, global::Endless.Stream.V1.ClassType>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForEnum(16, x => (int) x, x => (global::Endless.Stream.V1.ClassType) x), 10);
    private readonly pbc::MapField<string, global::Endless.Stream.V1.ClassType> selected_ = new pbc::MapField<string, global::Endless.Stream.V1.ClassType>();
    /// <summary>
    /// Selected is a map of ID -> class
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Endless.Stream.V1.ClassType> Selected {
      get { return selected_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CharacterSelected);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CharacterSelected other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Selected.Equals(other.Selected)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Selected.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      selected_.WriteTo(output, _map_selected_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += selected_.CalculateSize(_map_selected_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CharacterSelected other) {
      if (other == null) {
        return;
      }
      selected_.Add(other.selected_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            selected_.AddEntriesFrom(input, _map_selected_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Wave has some basic information about the wave
  /// </summary>
  public sealed partial class Wave : pb::IMessage<Wave> {
    private static readonly pb::MessageParser<Wave> _parser = new pb::MessageParser<Wave>(() => new Wave());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Wave> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Wave() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Wave(Wave other) : this() {
      num_ = other.num_;
      hasBoss_ = other.hasBoss_;
      level_ = other.level_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Wave Clone() {
      return new Wave(this);
    }

    /// <summary>Field number for the "num" field.</summary>
    public const int NumFieldNumber = 1;
    private int num_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Num {
      get { return num_; }
      set {
        num_ = value;
      }
    }

    /// <summary>Field number for the "has_boss" field.</summary>
    public const int HasBossFieldNumber = 2;
    private bool hasBoss_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasBoss {
      get { return hasBoss_; }
      set {
        hasBoss_ = value;
      }
    }

    /// <summary>Field number for the "level" field.</summary>
    public const int LevelFieldNumber = 3;
    private global::Endless.Stream.V1.Level level_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Level Level {
      get { return level_; }
      set {
        level_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Wave);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Wave other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Num != other.Num) return false;
      if (HasBoss != other.HasBoss) return false;
      if (Level != other.Level) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Num != 0) hash ^= Num.GetHashCode();
      if (HasBoss != false) hash ^= HasBoss.GetHashCode();
      if (Level != 0) hash ^= Level.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Num != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Num);
      }
      if (HasBoss != false) {
        output.WriteRawTag(16);
        output.WriteBool(HasBoss);
      }
      if (Level != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Level);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Num != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Num);
      }
      if (HasBoss != false) {
        size += 1 + 1;
      }
      if (Level != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Level);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Wave other) {
      if (other == null) {
        return;
      }
      if (other.Num != 0) {
        Num = other.Num;
      }
      if (other.HasBoss != false) {
        HasBoss = other.HasBoss;
      }
      if (other.Level != 0) {
        Level = other.Level;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Num = input.ReadInt32();
            break;
          }
          case 16: {
            HasBoss = input.ReadBool();
            break;
          }
          case 24: {
            Level = (global::Endless.Stream.V1.Level) input.ReadEnum();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// CurrentState is sent after something has happened to change the state.
  /// </summary>
  public sealed partial class CurrentState : pb::IMessage<CurrentState> {
    private static readonly pb::MessageParser<CurrentState> _parser = new pb::MessageParser<CurrentState>(() => new CurrentState());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<CurrentState> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CurrentState() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CurrentState(CurrentState other) : this() {
      monsters_ = other.monsters_.Clone();
      players_ = other.players_.Clone();
      CurrentPlayer = other.CurrentPlayer;
      display_ = other.display_;
      currentWave_ = other.currentWave_ != null ? other.currentWave_.Clone() : null;
      upcomingWaves_ = other.upcomingWaves_.Clone();
      audienceCount_ = other.audienceCount_;
      selected_ = other.selected_ != null ? other.selected_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public CurrentState Clone() {
      return new CurrentState(this);
    }

    /// <summary>Field number for the "monsters" field.</summary>
    public const int MonstersFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Endless.Stream.V1.Monster> _repeated_monsters_codec
        = pb::FieldCodec.ForMessage(10, global::Endless.Stream.V1.Monster.Parser);
    private readonly pbc::RepeatedField<global::Endless.Stream.V1.Monster> monsters_ = new pbc::RepeatedField<global::Endless.Stream.V1.Monster>();
    /// <summary>
    /// Monsters holds an array of the monsters in the current wave
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Endless.Stream.V1.Monster> Monsters {
      get { return monsters_; }
    }

    /// <summary>Field number for the "players" field.</summary>
    public const int PlayersFieldNumber = 2;
    private static readonly pbc::MapField<string, global::Endless.Stream.V1.Player>.Codec _map_players_codec
        = new pbc::MapField<string, global::Endless.Stream.V1.Player>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Endless.Stream.V1.Player.Parser), 18);
    private readonly pbc::MapField<string, global::Endless.Stream.V1.Player> players_ = new pbc::MapField<string, global::Endless.Stream.V1.Player>();
    /// <summary>
    /// Players contains a list of id->Player of who's in the game currently
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Endless.Stream.V1.Player> Players {
      get { return players_; }
    }

    /// <summary>Field number for the "current_player" field.</summary>
    public const int CurrentPlayerFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _single_currentPlayer_codec = pb::FieldCodec.ForClassWrapper<string>(26);
    private string currentPlayer_;
    /// <summary>
    /// CurrentPlayer is the UUID of the player whose turn it is currently.
    /// If it is null, it is currently a monster's turn or the players aren't in battle ( ie, in the store or all dead ).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string CurrentPlayer {
      get { return currentPlayer_; }
      set {
        currentPlayer_ = value;
      }
    }


    /// <summary>Field number for the "display" field.</summary>
    public const int DisplayFieldNumber = 4;
    private global::Endless.Stream.V1.Display display_ = 0;
    /// <summary>
    /// Display indicates what screen the game is on currently. Clients don't have to care about all of these.
    /// For example, the player display screen doesn't care about the NewWave display.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Display Display {
      get { return display_; }
      set {
        display_ = value;
      }
    }

    /// <summary>Field number for the "current_wave" field.</summary>
    public const int CurrentWaveFieldNumber = 5;
    private global::Endless.Stream.V1.Wave currentWave_;
    /// <summary>
    /// CurrentWave is used to indicate what the current wave is
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Wave CurrentWave {
      get { return currentWave_; }
      set {
        currentWave_ = value;
      }
    }

    /// <summary>Field number for the "upcoming_waves" field.</summary>
    public const int UpcomingWavesFieldNumber = 6;
    private static readonly pbc::MapField<int, global::Endless.Stream.V1.Wave>.Codec _map_upcomingWaves_codec
        = new pbc::MapField<int, global::Endless.Stream.V1.Wave>.Codec(pb::FieldCodec.ForInt32(8), pb::FieldCodec.ForMessage(18, global::Endless.Stream.V1.Wave.Parser), 50);
    private readonly pbc::MapField<int, global::Endless.Stream.V1.Wave> upcomingWaves_ = new pbc::MapField<int, global::Endless.Stream.V1.Wave>();
    /// <summary>
    /// UpcomingWaves is used to show an "upcoming waves" tracker on the shared info screen
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<int, global::Endless.Stream.V1.Wave> UpcomingWaves {
      get { return upcomingWaves_; }
    }

    /// <summary>Field number for the "audience_count" field.</summary>
    public const int AudienceCountFieldNumber = 7;
    private long audienceCount_;
    /// <summary>
    /// AudienceCount is how many folks are in the active audience ( connected to the current game
    /// as an audience member )
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long AudienceCount {
      get { return audienceCount_; }
      set {
        audienceCount_ = value;
      }
    }

    /// <summary>Field number for the "selected" field.</summary>
    public const int SelectedFieldNumber = 8;
    private global::Endless.Stream.V1.CharacterSelected selected_;
    /// <summary>
    /// list of who's selected what characters
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.CharacterSelected Selected {
      get { return selected_; }
      set {
        selected_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as CurrentState);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(CurrentState other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!monsters_.Equals(other.monsters_)) return false;
      if (!Players.Equals(other.Players)) return false;
      if (CurrentPlayer != other.CurrentPlayer) return false;
      if (Display != other.Display) return false;
      if (!object.Equals(CurrentWave, other.CurrentWave)) return false;
      if (!UpcomingWaves.Equals(other.UpcomingWaves)) return false;
      if (AudienceCount != other.AudienceCount) return false;
      if (!object.Equals(Selected, other.Selected)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= monsters_.GetHashCode();
      hash ^= Players.GetHashCode();
      if (currentPlayer_ != null) hash ^= CurrentPlayer.GetHashCode();
      if (Display != 0) hash ^= Display.GetHashCode();
      if (currentWave_ != null) hash ^= CurrentWave.GetHashCode();
      hash ^= UpcomingWaves.GetHashCode();
      if (AudienceCount != 0L) hash ^= AudienceCount.GetHashCode();
      if (selected_ != null) hash ^= Selected.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      monsters_.WriteTo(output, _repeated_monsters_codec);
      players_.WriteTo(output, _map_players_codec);
      if (currentPlayer_ != null) {
        _single_currentPlayer_codec.WriteTagAndValue(output, CurrentPlayer);
      }
      if (Display != 0) {
        output.WriteRawTag(32);
        output.WriteEnum((int) Display);
      }
      if (currentWave_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(CurrentWave);
      }
      upcomingWaves_.WriteTo(output, _map_upcomingWaves_codec);
      if (AudienceCount != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(AudienceCount);
      }
      if (selected_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Selected);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += monsters_.CalculateSize(_repeated_monsters_codec);
      size += players_.CalculateSize(_map_players_codec);
      if (currentPlayer_ != null) {
        size += _single_currentPlayer_codec.CalculateSizeWithTag(CurrentPlayer);
      }
      if (Display != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Display);
      }
      if (currentWave_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CurrentWave);
      }
      size += upcomingWaves_.CalculateSize(_map_upcomingWaves_codec);
      if (AudienceCount != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(AudienceCount);
      }
      if (selected_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Selected);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(CurrentState other) {
      if (other == null) {
        return;
      }
      monsters_.Add(other.monsters_);
      players_.Add(other.players_);
      if (other.currentPlayer_ != null) {
        if (currentPlayer_ == null || other.CurrentPlayer != "") {
          CurrentPlayer = other.CurrentPlayer;
        }
      }
      if (other.Display != 0) {
        Display = other.Display;
      }
      if (other.currentWave_ != null) {
        if (currentWave_ == null) {
          CurrentWave = new global::Endless.Stream.V1.Wave();
        }
        CurrentWave.MergeFrom(other.CurrentWave);
      }
      upcomingWaves_.Add(other.upcomingWaves_);
      if (other.AudienceCount != 0L) {
        AudienceCount = other.AudienceCount;
      }
      if (other.selected_ != null) {
        if (selected_ == null) {
          Selected = new global::Endless.Stream.V1.CharacterSelected();
        }
        Selected.MergeFrom(other.Selected);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            monsters_.AddEntriesFrom(input, _repeated_monsters_codec);
            break;
          }
          case 18: {
            players_.AddEntriesFrom(input, _map_players_codec);
            break;
          }
          case 26: {
            string value = _single_currentPlayer_codec.Read(input);
            if (currentPlayer_ == null || value != "") {
              CurrentPlayer = value;
            }
            break;
          }
          case 32: {
            Display = (global::Endless.Stream.V1.Display) input.ReadEnum();
            break;
          }
          case 42: {
            if (currentWave_ == null) {
              CurrentWave = new global::Endless.Stream.V1.Wave();
            }
            input.ReadMessage(CurrentWave);
            break;
          }
          case 50: {
            upcomingWaves_.AddEntriesFrom(input, _map_upcomingWaves_codec);
            break;
          }
          case 56: {
            AudienceCount = input.ReadInt64();
            break;
          }
          case 66: {
            if (selected_ == null) {
              Selected = new global::Endless.Stream.V1.CharacterSelected();
            }
            input.ReadMessage(Selected);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Tick is a message that's sent out on a set schedule
  /// that informs things like countdown timers and whatnot
  /// </summary>
  public sealed partial class Tick : pb::IMessage<Tick> {
    private static readonly pb::MessageParser<Tick> _parser = new pb::MessageParser<Tick>(() => new Tick());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Tick> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tick() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tick(Tick other) : this() {
      time_ = other.time_ != null ? other.time_.Clone() : null;
      progress_ = other.progress_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Tick Clone() {
      return new Tick(this);
    }

    /// <summary>Field number for the "time" field.</summary>
    public const int TimeFieldNumber = 1;
    private global::Google.Protobuf.WellKnownTypes.Timestamp time_;
    /// <summary>
    /// Time is just so that the game clients can ignore ticks from too far in the past
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Google.Protobuf.WellKnownTypes.Timestamp Time {
      get { return time_; }
      set {
        time_ = value;
      }
    }

    /// <summary>Field number for the "progress" field.</summary>
    public const int ProgressFieldNumber = 2;
    private static readonly pbc::MapField<string, int>.Codec _map_progress_codec
        = new pbc::MapField<string, int>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForInt32(16), 18);
    private readonly pbc::MapField<string, int> progress_ = new pbc::MapField<string, int>();
    /// <summary>
    /// Progress is a map of type->count. It is used to keep track of any progress bars that are ticking down,
    /// where the string name matches a ProgressBarType value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, int> Progress {
      get { return progress_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Tick);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Tick other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Time, other.Time)) return false;
      if (!Progress.Equals(other.Progress)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (time_ != null) hash ^= Time.GetHashCode();
      hash ^= Progress.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (time_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Time);
      }
      progress_.WriteTo(output, _map_progress_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (time_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Time);
      }
      size += progress_.CalculateSize(_map_progress_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Tick other) {
      if (other == null) {
        return;
      }
      if (other.time_ != null) {
        if (time_ == null) {
          Time = new global::Google.Protobuf.WellKnownTypes.Timestamp();
        }
        Time.MergeFrom(other.Time);
      }
      progress_.Add(other.progress_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (time_ == null) {
              Time = new global::Google.Protobuf.WellKnownTypes.Timestamp();
            }
            input.ReadMessage(Time);
            break;
          }
          case 18: {
            progress_.AddEntriesFrom(input, _map_progress_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class JoinedGame : pb::IMessage<JoinedGame> {
    private static readonly pb::MessageParser<JoinedGame> _parser = new pb::MessageParser<JoinedGame>(() => new JoinedGame());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<JoinedGame> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JoinedGame() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JoinedGame(JoinedGame other) : this() {
      id_ = other.id_;
      asAudience_ = other.asAudience_;
      isVip_ = other.isVip_;
      name_ = other.name_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public JoinedGame Clone() {
      return new JoinedGame(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    /// Id is the UUID of the player
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "as_audience" field.</summary>
    public const int AsAudienceFieldNumber = 2;
    private bool asAudience_;
    /// <summary>
    /// AsAudience lets the client know if the player has joined as one of the four main or if they
    /// have joined as part of the audience
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AsAudience {
      get { return asAudience_; }
      set {
        asAudience_ = value;
      }
    }

    /// <summary>Field number for the "is_vip" field.</summary>
    public const int IsVipFieldNumber = 3;
    private bool isVip_;
    /// <summary>
    /// IsVIP is to indicate if the player is "player 1", ie, they're the player
    /// that gets to make decisions like when to start the game
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsVip {
      get { return isVip_; }
      set {
        isVip_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 4;
    private string name_ = "";
    /// <summary>
    /// Name is the name of the player
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as JoinedGame);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(JoinedGame other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (AsAudience != other.AsAudience) return false;
      if (IsVip != other.IsVip) return false;
      if (Name != other.Name) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (AsAudience != false) hash ^= AsAudience.GetHashCode();
      if (IsVip != false) hash ^= IsVip.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (AsAudience != false) {
        output.WriteRawTag(16);
        output.WriteBool(AsAudience);
      }
      if (IsVip != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsVip);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Name);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (AsAudience != false) {
        size += 1 + 1;
      }
      if (IsVip != false) {
        size += 1 + 1;
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(JoinedGame other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.AsAudience != false) {
        AsAudience = other.AsAudience;
      }
      if (other.IsVip != false) {
        IsVip = other.IsVip;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 16: {
            AsAudience = input.ReadBool();
            break;
          }
          case 24: {
            IsVip = input.ReadBool();
            break;
          }
          case 34: {
            Name = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Action is sent when an actor in the game does something ( attacks a target, uses a skill, etc ),
  /// that requires the UI ( player or status ) to display something.
  /// </summary>
  public sealed partial class Action : pb::IMessage<Action> {
    private static readonly pb::MessageParser<Action> _parser = new pb::MessageParser<Action>(() => new Action());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Action> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Action() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Action(Action other) : this() {
      id_ = other.id_;
      actorId_ = other.actorId_;
      targetIds_ = other.targetIds_.Clone();
      msg_ = other.msg_;
      skill_ = other.skill_ != null ? other.skill_.Clone() : null;
      value_ = other.value_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Action Clone() {
      return new Action(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private string id_ = "";
    /// <summary>
    /// Id is a UUID, and should be used in the ActionComplete message
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Id {
      get { return id_; }
      set {
        id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "actor_id" field.</summary>
    public const int ActorIdFieldNumber = 2;
    private string actorId_ = "";
    /// <summary>
    /// ActorId is the UUID of the actor performing the action
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ActorId {
      get { return actorId_; }
      set {
        actorId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "target_ids" field.</summary>
    public const int TargetIdsFieldNumber = 3;
    private static readonly pb::FieldCodec<string> _repeated_targetIds_codec
        = pb::FieldCodec.ForString(26);
    private readonly pbc::RepeatedField<string> targetIds_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// TargetIds is the UUID of the target of the action. It may be empty if the action
    /// has no target ( ie, a move action ).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> TargetIds {
      get { return targetIds_; }
    }

    /// <summary>Field number for the "msg" field.</summary>
    public const int MsgFieldNumber = 4;
    private string msg_ = "";
    /// <summary>
    /// Msg is a human readable message of what the action is, such as "Bob hits the Kobold with Divine Strike
    /// for 10 points of damage"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Msg {
      get { return msg_; }
      set {
        msg_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "skill" field.</summary>
    public const int SkillFieldNumber = 6;
    private global::Endless.Stream.V1.Skill skill_;
    /// <summary>
    /// Skill is the skill used
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Skill Skill {
      get { return skill_; }
      set {
        skill_ = value;
      }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 7;
    private int value_;
    /// <summary>
    /// Value is the amount of damage ( or healing ) done by the skill
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Value {
      get { return value_; }
      set {
        value_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Action);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Action other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (ActorId != other.ActorId) return false;
      if(!targetIds_.Equals(other.targetIds_)) return false;
      if (Msg != other.Msg) return false;
      if (!object.Equals(Skill, other.Skill)) return false;
      if (Value != other.Value) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id.Length != 0) hash ^= Id.GetHashCode();
      if (ActorId.Length != 0) hash ^= ActorId.GetHashCode();
      hash ^= targetIds_.GetHashCode();
      if (Msg.Length != 0) hash ^= Msg.GetHashCode();
      if (skill_ != null) hash ^= Skill.GetHashCode();
      if (Value != 0) hash ^= Value.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Id);
      }
      if (ActorId.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ActorId);
      }
      targetIds_.WriteTo(output, _repeated_targetIds_codec);
      if (Msg.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Msg);
      }
      if (skill_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(Skill);
      }
      if (Value != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(Value);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
      }
      if (ActorId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ActorId);
      }
      size += targetIds_.CalculateSize(_repeated_targetIds_codec);
      if (Msg.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Msg);
      }
      if (skill_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Skill);
      }
      if (Value != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Value);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Action other) {
      if (other == null) {
        return;
      }
      if (other.Id.Length != 0) {
        Id = other.Id;
      }
      if (other.ActorId.Length != 0) {
        ActorId = other.ActorId;
      }
      targetIds_.Add(other.targetIds_);
      if (other.Msg.Length != 0) {
        Msg = other.Msg;
      }
      if (other.skill_ != null) {
        if (skill_ == null) {
          Skill = new global::Endless.Stream.V1.Skill();
        }
        Skill.MergeFrom(other.Skill);
      }
      if (other.Value != 0) {
        Value = other.Value;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Id = input.ReadString();
            break;
          }
          case 18: {
            ActorId = input.ReadString();
            break;
          }
          case 26: {
            targetIds_.AddEntriesFrom(input, _repeated_targetIds_codec);
            break;
          }
          case 34: {
            Msg = input.ReadString();
            break;
          }
          case 50: {
            if (skill_ == null) {
              Skill = new global::Endless.Stream.V1.Skill();
            }
            input.ReadMessage(Skill);
            break;
          }
          case 56: {
            Value = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Sent when the players enter the store, contains the inventory &amp; prices of
  /// what's in the store
  /// </summary>
  public sealed partial class StoreInventory : pb::IMessage<StoreInventory> {
    private static readonly pb::MessageParser<StoreInventory> _parser = new pb::MessageParser<StoreInventory>(() => new StoreInventory());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<StoreInventory> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StoreInventory() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StoreInventory(StoreInventory other) : this() {
      inventory_ = other.inventory_.Clone();
      prices_ = other.prices_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public StoreInventory Clone() {
      return new StoreInventory(this);
    }

    /// <summary>Field number for the "inventory" field.</summary>
    public const int InventoryFieldNumber = 1;
    private static readonly pbc::MapField<string, global::Endless.Stream.V1.Item>.Codec _map_inventory_codec
        = new pbc::MapField<string, global::Endless.Stream.V1.Item>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForMessage(18, global::Endless.Stream.V1.Item.Parser), 10);
    private readonly pbc::MapField<string, global::Endless.Stream.V1.Item> inventory_ = new pbc::MapField<string, global::Endless.Stream.V1.Item>();
    /// <summary>
    /// Inventory is a map of UUID -> Item of what's in the store
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, global::Endless.Stream.V1.Item> Inventory {
      get { return inventory_; }
    }

    /// <summary>Field number for the "prices" field.</summary>
    public const int PricesFieldNumber = 2;
    private static readonly pbc::MapField<string, int>.Codec _map_prices_codec
        = new pbc::MapField<string, int>.Codec(pb::FieldCodec.ForString(10), pb::FieldCodec.ForInt32(16), 18);
    private readonly pbc::MapField<string, int> prices_ = new pbc::MapField<string, int>();
    /// <summary>
    /// Prices is a map of UUID -> price of what's in the store
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::MapField<string, int> Prices {
      get { return prices_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as StoreInventory);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(StoreInventory other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!Inventory.Equals(other.Inventory)) return false;
      if (!Prices.Equals(other.Prices)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= Inventory.GetHashCode();
      hash ^= Prices.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      inventory_.WriteTo(output, _map_inventory_codec);
      prices_.WriteTo(output, _map_prices_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += inventory_.CalculateSize(_map_inventory_codec);
      size += prices_.CalculateSize(_map_prices_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(StoreInventory other) {
      if (other == null) {
        return;
      }
      inventory_.Add(other.inventory_);
      prices_.Add(other.prices_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            inventory_.AddEntriesFrom(input, _map_inventory_codec);
            break;
          }
          case 18: {
            prices_.AddEntriesFrom(input, _map_prices_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Output is sent by the game server to update clients on various parts of the game
  /// </summary>
  public sealed partial class Output : pb::IMessage<Output> {
    private static readonly pb::MessageParser<Output> _parser = new pb::MessageParser<Output>(() => new Output());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Output> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Endless.Stream.V1.OutputReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Output() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Output(Output other) : this() {
      switch (other.DataCase) {
        case DataOneofCase.State:
          State = other.State.Clone();
          break;
        case DataOneofCase.Joined:
          Joined = other.Joined.Clone();
          break;
        case DataOneofCase.Tick:
          Tick = other.Tick.Clone();
          break;
        case DataOneofCase.Msg:
          Msg = other.Msg.Clone();
          break;
        case DataOneofCase.Action:
          Action = other.Action.Clone();
          break;
        case DataOneofCase.Selected:
          Selected = other.Selected.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Output Clone() {
      return new Output(this);
    }

    /// <summary>Field number for the "state" field.</summary>
    public const int StateFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.CurrentState State {
      get { return dataCase_ == DataOneofCase.State ? (global::Endless.Stream.V1.CurrentState) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.State;
      }
    }

    /// <summary>Field number for the "joined" field.</summary>
    public const int JoinedFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.JoinedGame Joined {
      get { return dataCase_ == DataOneofCase.Joined ? (global::Endless.Stream.V1.JoinedGame) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Joined;
      }
    }

    /// <summary>Field number for the "tick" field.</summary>
    public const int TickFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Tick Tick {
      get { return dataCase_ == DataOneofCase.Tick ? (global::Endless.Stream.V1.Tick) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Tick;
      }
    }

    /// <summary>Field number for the "msg" field.</summary>
    public const int MsgFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.EventMessage Msg {
      get { return dataCase_ == DataOneofCase.Msg ? (global::Endless.Stream.V1.EventMessage) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Msg;
      }
    }

    /// <summary>Field number for the "action" field.</summary>
    public const int ActionFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.Action Action {
      get { return dataCase_ == DataOneofCase.Action ? (global::Endless.Stream.V1.Action) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Action;
      }
    }

    /// <summary>Field number for the "selected" field.</summary>
    public const int SelectedFieldNumber = 6;
    /// <summary>
    /// StoreInventory store_inventory = 7;
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Endless.Stream.V1.CharacterSelected Selected {
      get { return dataCase_ == DataOneofCase.Selected ? (global::Endless.Stream.V1.CharacterSelected) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Selected;
      }
    }

    private object data_;
    /// <summary>Enum of possible cases for the "data" oneof.</summary>
    public enum DataOneofCase {
      None = 0,
      State = 1,
      Joined = 2,
      Tick = 3,
      Msg = 4,
      Action = 5,
      Selected = 6,
    }
    private DataOneofCase dataCase_ = DataOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DataOneofCase DataCase {
      get { return dataCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearData() {
      dataCase_ = DataOneofCase.None;
      data_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Output);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Output other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(State, other.State)) return false;
      if (!object.Equals(Joined, other.Joined)) return false;
      if (!object.Equals(Tick, other.Tick)) return false;
      if (!object.Equals(Msg, other.Msg)) return false;
      if (!object.Equals(Action, other.Action)) return false;
      if (!object.Equals(Selected, other.Selected)) return false;
      if (DataCase != other.DataCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (dataCase_ == DataOneofCase.State) hash ^= State.GetHashCode();
      if (dataCase_ == DataOneofCase.Joined) hash ^= Joined.GetHashCode();
      if (dataCase_ == DataOneofCase.Tick) hash ^= Tick.GetHashCode();
      if (dataCase_ == DataOneofCase.Msg) hash ^= Msg.GetHashCode();
      if (dataCase_ == DataOneofCase.Action) hash ^= Action.GetHashCode();
      if (dataCase_ == DataOneofCase.Selected) hash ^= Selected.GetHashCode();
      hash ^= (int) dataCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (dataCase_ == DataOneofCase.State) {
        output.WriteRawTag(10);
        output.WriteMessage(State);
      }
      if (dataCase_ == DataOneofCase.Joined) {
        output.WriteRawTag(18);
        output.WriteMessage(Joined);
      }
      if (dataCase_ == DataOneofCase.Tick) {
        output.WriteRawTag(26);
        output.WriteMessage(Tick);
      }
      if (dataCase_ == DataOneofCase.Msg) {
        output.WriteRawTag(34);
        output.WriteMessage(Msg);
      }
      if (dataCase_ == DataOneofCase.Action) {
        output.WriteRawTag(42);
        output.WriteMessage(Action);
      }
      if (dataCase_ == DataOneofCase.Selected) {
        output.WriteRawTag(50);
        output.WriteMessage(Selected);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (dataCase_ == DataOneofCase.State) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(State);
      }
      if (dataCase_ == DataOneofCase.Joined) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Joined);
      }
      if (dataCase_ == DataOneofCase.Tick) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tick);
      }
      if (dataCase_ == DataOneofCase.Msg) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Msg);
      }
      if (dataCase_ == DataOneofCase.Action) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Action);
      }
      if (dataCase_ == DataOneofCase.Selected) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Selected);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Output other) {
      if (other == null) {
        return;
      }
      switch (other.DataCase) {
        case DataOneofCase.State:
          if (State == null) {
            State = new global::Endless.Stream.V1.CurrentState();
          }
          State.MergeFrom(other.State);
          break;
        case DataOneofCase.Joined:
          if (Joined == null) {
            Joined = new global::Endless.Stream.V1.JoinedGame();
          }
          Joined.MergeFrom(other.Joined);
          break;
        case DataOneofCase.Tick:
          if (Tick == null) {
            Tick = new global::Endless.Stream.V1.Tick();
          }
          Tick.MergeFrom(other.Tick);
          break;
        case DataOneofCase.Msg:
          if (Msg == null) {
            Msg = new global::Endless.Stream.V1.EventMessage();
          }
          Msg.MergeFrom(other.Msg);
          break;
        case DataOneofCase.Action:
          if (Action == null) {
            Action = new global::Endless.Stream.V1.Action();
          }
          Action.MergeFrom(other.Action);
          break;
        case DataOneofCase.Selected:
          if (Selected == null) {
            Selected = new global::Endless.Stream.V1.CharacterSelected();
          }
          Selected.MergeFrom(other.Selected);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Endless.Stream.V1.CurrentState subBuilder = new global::Endless.Stream.V1.CurrentState();
            if (dataCase_ == DataOneofCase.State) {
              subBuilder.MergeFrom(State);
            }
            input.ReadMessage(subBuilder);
            State = subBuilder;
            break;
          }
          case 18: {
            global::Endless.Stream.V1.JoinedGame subBuilder = new global::Endless.Stream.V1.JoinedGame();
            if (dataCase_ == DataOneofCase.Joined) {
              subBuilder.MergeFrom(Joined);
            }
            input.ReadMessage(subBuilder);
            Joined = subBuilder;
            break;
          }
          case 26: {
            global::Endless.Stream.V1.Tick subBuilder = new global::Endless.Stream.V1.Tick();
            if (dataCase_ == DataOneofCase.Tick) {
              subBuilder.MergeFrom(Tick);
            }
            input.ReadMessage(subBuilder);
            Tick = subBuilder;
            break;
          }
          case 34: {
            global::Endless.Stream.V1.EventMessage subBuilder = new global::Endless.Stream.V1.EventMessage();
            if (dataCase_ == DataOneofCase.Msg) {
              subBuilder.MergeFrom(Msg);
            }
            input.ReadMessage(subBuilder);
            Msg = subBuilder;
            break;
          }
          case 42: {
            global::Endless.Stream.V1.Action subBuilder = new global::Endless.Stream.V1.Action();
            if (dataCase_ == DataOneofCase.Action) {
              subBuilder.MergeFrom(Action);
            }
            input.ReadMessage(subBuilder);
            Action = subBuilder;
            break;
          }
          case 50: {
            global::Endless.Stream.V1.CharacterSelected subBuilder = new global::Endless.Stream.V1.CharacterSelected();
            if (dataCase_ == DataOneofCase.Selected) {
              subBuilder.MergeFrom(Selected);
            }
            input.ReadMessage(subBuilder);
            Selected = subBuilder;
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
